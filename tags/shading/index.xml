<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shading on The Danger Zone</title>
    <link>https://therealmjp.github.io/tags/shading/</link>
    <description>Recent content in Shading on The Danger Zone</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Oct 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://therealmjp.github.io/tags/shading/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linking DXIL Binaries Using DXC</title>
      <link>https://therealmjp.github.io/posts/dxil-linking/</link>
      <pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/dxil-linking/</guid>
      <description>While doing some research for a different blog post, I happened to discover that DXC is capable of linking together multiple compiled DXIL binaries into single complete shader program of any stage (vertex, pixel, compute, etc.). I had known that this was a thing you could do for D3D11 with the old fxc-based compiler stack, but I wasn&#39;t aware that DXC could now do it as well. It turns out that the new lib_6_x targets aren&#39;t just usable for creating DXR state objects: you can also compile whatever you want into libraries and link them together into a full binary for a non-raytracing shader.</description>
    </item>
    
    <item>
      <title>Approximating Subsurface Scattering With Spherical Gaussians</title>
      <link>https://therealmjp.github.io/posts/sss-sg/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/sss-sg/</guid>
      <description>In my previous post, where I gave a quick overview of real-time subsurface scattering techniques, I mentioned that one of the potential downsides of preintegrated subsurface scattering was that it relied on sampling a precomputed lookup texture for storing the appropriate &amp;quot;wrapped&amp;quot; or &amp;quot;blurred&amp;quot; lighting response for a given lighting angle and surface curvature. Depending on the hardware you&#39;re working with as well as the exact details of the shader program, sampling a lookup texture can be either a good or a bad thing.</description>
    </item>
    
    <item>
      <title>An Introduction To Real-Time Subsurface Scattering</title>
      <link>https://therealmjp.github.io/posts/sss-intro/</link>
      <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/sss-intro/</guid>
      <description>A little while ago I was doing some research into the state-of-the-art for approximating subsurface scattering effects in real-time (mainly for skin rendering), and I had taken a bunch of loose notes to help me keep all of the details straight. I thought it might be useful to turn those notes into a full blog post, in case anyone else out there needs an overview of what&#39;s commonly used to shade skin and other materials in recent games.</description>
    </item>
    
    <item>
      <title>Half The Precision, Twice The Fun: Working With FP16 In HLSL</title>
      <link>https://therealmjp.github.io/posts/shader-fp16/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/shader-fp16/</guid>
      <description>Those of you who have been working on desktop and console graphics long enough will remember working with fp16 math in shaders during the D3D9 era. Back then HLSL supported the half scalar type, which corresponded to a floating-point value using 16-bits of precision. Using it was crucial for extracting the best performance from Nvidia&#39;s FX series, 6-series, and 7-series hardware, since it could perform many fp16 operations at faster rate than it could for full-precision 32-bit values.</description>
    </item>
    
  </channel>
</rss>