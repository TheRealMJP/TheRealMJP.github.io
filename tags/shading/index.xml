<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shading on The Danger Zone</title>
    <link>https://therealmjp.github.io/tags/shading/</link>
    <description>Recent content in Shading on The Danger Zone</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Oct 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://therealmjp.github.io/tags/shading/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>An Introduction To Real-Time Subsurface Scattering</title>
      <link>https://therealmjp.github.io/posts/sss-intro/</link>
      <pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/sss-intro/</guid>
      <description>A little while ago I was doing some research into the state-of-the-art for approximating subsurface scattering effects in real-time (mainly for skin rendering), and I had taken a bunch of loose notes to help me keep all of the details straight. I thought it might be useful to turn those notes into a full blog post, in case anyone else out there needs an overview of what&#39;s commonly used to shade skin and other materials in recent games.</description>
    </item>
    
    <item>
      <title>Half The Precision, Twice The Fun: Working With FP16 In HLSL</title>
      <link>https://therealmjp.github.io/posts/shader-fp16/</link>
      <pubDate>Tue, 01 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://therealmjp.github.io/posts/shader-fp16/</guid>
      <description>Those of you who have been working on desktop and console graphics long enough will remember working with fp16 math in shaders during the D3D9 era. Back then HLSL supported the half scalar type, which corresponded to a floating-point value using 16-bits of precision. Using it was crucial for extracting the best performance from Nvidia&#39;s FX series, 6-series, and 7-series hardware, since it could perform many fp16 operations at faster rate than it could for full-precision 32-bit values.</description>
    </item>
    
  </channel>
</rss>