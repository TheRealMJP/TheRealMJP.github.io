<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="Stairway To (Programmable Sample Point) Heaven">
<meta itemprop="description" content="What Is and Should Never Be Historically, the sub-pixel location of MSAA sample points was totally out of your control as a programmer. Typically the hardware used rotated grid patterns such as this one, which were fixed for every pixel in your render target. For FEATURE_LEVEL_10_1, D3D added the concept of standard sample patterns that were required to be supported by the hardware. These were nice, in that you could specify the appropriate quality level and know exactly where the samples would be located."><meta itemprop="datePublished" content="2015-09-14T03:31:37+00:00" />
<meta itemprop="dateModified" content="2015-09-14T03:31:37+00:00" />
<meta itemprop="wordCount" content="5237">
<meta itemprop="keywords" content="Uncategorized," /><meta property="og:title" content="Stairway To (Programmable Sample Point) Heaven" />
<meta property="og:description" content="What Is and Should Never Be Historically, the sub-pixel location of MSAA sample points was totally out of your control as a programmer. Typically the hardware used rotated grid patterns such as this one, which were fixed for every pixel in your render target. For FEATURE_LEVEL_10_1, D3D added the concept of standard sample patterns that were required to be supported by the hardware. These were nice, in that you could specify the appropriate quality level and know exactly where the samples would be located." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therealmjp.github.io/posts/programmable-sample-points/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-09-14T03:31:37+00:00" />
<meta property="article:modified_time" content="2015-09-14T03:31:37+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Stairway To (Programmable Sample Point) Heaven"/>
<meta name="twitter:description" content="What Is and Should Never Be Historically, the sub-pixel location of MSAA sample points was totally out of your control as a programmer. Typically the hardware used rotated grid patterns such as this one, which were fixed for every pixel in your render target. For FEATURE_LEVEL_10_1, D3D added the concept of standard sample patterns that were required to be supported by the hardware. These were nice, in that you could specify the appropriate quality level and know exactly where the samples would be located."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Stairway To (Programmable Sample Point) Heaven</title>
	<link rel="stylesheet" href="https://therealmjp.github.io/css/style.min.4bc523c643bd50ebce05154df32e255bc3b0c9bae8e5b0be991a7f5163fae5af.css" integrity="sha256-S8UjxkO9UOvOBRVN8y4lW8Owybro5bC+mRp/UWP65a8=">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://therealmjp.github.io/">The Danger Zone</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://therealmjp.github.io/posts/">Posts</a>
				<a href="https://therealmjp.github.io/about/">About</a>
				<a href="https://therealmjp.github.io/publications/">Publications</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/TheRealMJP" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://bsky.app/profile/mjp123.bsky.social" target="_blank" rel="noopener me" title="Bluesky"><svg width="24" height="24" viewBox="0 0 600 600" preserveAspectRatio="xMinYMin meet" version="1.1" xmlns="http://www.w3.org/2000/svg" class="feather">
 <path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" style="font-variation-settings:normal" stroke="currentColor" stroke-linejoin="bevel" paint-order="stroke fill markers" fill="#1185fe"/>
</svg></a><a href="mailto:mpettineo@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://therealmjp.github.io/posts/">Posts</a></li>
			<li><a href="https://therealmjp.github.io/about/">About</a></li>
			<li><a href="https://therealmjp.github.io/publications/">Publications</a></li>
		</ul>
	</div>




	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Sep 14, 2015</span></div>
				<h1>Stairway To (Programmable Sample Point) Heaven</h1>
			</header>
			<div class="content">
				<h2 id="what-is-and-should-never-be">What Is and Should Never Be<a href="#what-is-and-should-never-be" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Historically, the sub-pixel location of MSAA sample points was totally out of your control as a programmer. Typically the hardware used rotated grid patterns such as <a href="/images/converted/programmable-sample-points/msaa_4xpattern.png">this one</a>, which were fixed for every pixel in your render target. For <code>FEATURE_LEVEL_10_1</code>, D3D added the concept of <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/Ff476218(v=VS.85).aspx">standard sample patterns</a> that were required to be supported by the hardware. These were nice, in that you could specify the appropriate quality level and know exactly where the samples would be located. Without that, you either had to use <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb943997(v=vs.85).aspx">shader intrinsics</a> or resort to <a href="../msaa-sample-pattern-detector/">wackier methods</a> for figuring out the sample positions. In theory it also gives you a very limited ability to control where sample points are located, but in practice the GPU vendors just made the standard multisample patterns the only patterns that they supported. So if you specified quality level 0, you got the same pattern as if you specified <code>D3D11_STANDARD_MULTISAMPLE_PATTERN</code>.</p>
<p>Fairly recently, we&rsquo;ve finally seen the idea of programmable sample points getting some major attention. This has primarily came from Nvidia, who just added this functionality to their second-generation Maxwell architecture. You&rsquo;ve probably seen <a href="http://www.geforce.com/hardware/technology/mfaa/technology">some</a> of the <a href="http://www.extremetech.com/gaming/194629-analyzing-nvidias-new-aa-can-mfaa-improve-image-quality-without-a-frame-rate-hit">articles</a> about their new &ldquo;Multi-Frame Sampled Anti-Aliasing&rdquo; (MFAA), which exploits the new hardware capabilities to jitter MSAA sample positions across alternating frames[1]<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. The idea is that you can achieve a doubled effective sampling rate, as long as your resolve intelligently retrieves the subsamples from your previous frame. They also incorporate ideas from <a href="http://www.cs.ubc.ca/~heidrich/Papers/RW.01_2.pdf">interleaved sampling</a>, by varying their sample locations across a 2x2 quad instead of using the same pattern for all pixels. While the idea of yet-another control panel AA setting probably won&rsquo;t do more than elicit some collective groans from the graphics community, it should at least get us thinking about what we might do if provided with full access to this new functionality for ourselves. And now that Nvidia has added  an <a href="https://developer.nvidia.com/sites/default/files/akamai/opengl/specs/GL_NV_sample_locations.txt">OpenGL extension</a> as well as a corresponding D3D11 extension to their proprietary <a href="https://developer.nvidia.com/nvapi">NVAPI</a>, we can finally try out our own ideas (unless you work on consoles, in which case you <a href="http://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pptx">may have</a> been <a href="http://advances.realtimerendering.com/s2014/drobot/HRAA_notes_final.pdf">experimenting</a> with them already!).</p>
<p>As for AMD, they&rsquo;ve actually supported some form of programmable sample points since as far back as <a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/10/R6xx_3D_Registers.pdf">R600</a>, at least if the command buffer documentation is accurate (look, for PA_SC_AA_SAMPLE_LOCS). Either way, <a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/10/SI_3D_registers.pdf">Southern Islands</a> certainly has support for varying sample locations across a 2x2 quad of pixels, which puts it on par with the functionality present in Maxwell 2.0. It&rsquo;s a little strange to that AMD hasn&rsquo;t done much to promote this functionality in the way that Nvidia has, considering they&rsquo;ve had it for so long. Currently there&rsquo;s no way to access this feature through D3D, but they have had an <a href="https://www.opengl.org/registry/specs/AMD/sample_positions.txt">OpenGL extension</a> for a long time now (thanks to <a href="https://twitter.com/NIV_Anteru">Matthäus Chajdas</a> and <a href="https://twitter.com/grahamsellers">Graham Sellers</a> for pointing out the extension!).</p>
<p>I&rsquo;m not particularly knowledgeable about Intel GPU&rsquo;s, and some quick searching didn&rsquo;t return anything to indicate that they might be able to specify custom sample points. If anyone knows otherwise, then please let me know!</p>
<p><em>Update: Andrew Lauritzen has informed me via <a href="https://twitter.com/AndrewLauritzen/status/643458084195581952">Twitter</a> that Intel GPU&rsquo;s do in fact support custom sample locations! Thank you again, Andrew!</em></p>
<h2 id="how-does-it-work">How Does It Work?<a href="#how-does-it-work" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Before we get into use cases, let&rsquo;s quickly go over how to actually work with programmable sample points. Since I usually only use D3D when working on PC&rsquo;s, I&rsquo;m going to focus on the extensions for Maxwell GPU&rsquo;s that were exposed in NVAPI. If you look in the NVAPI headers, you&rsquo;ll find a function for creating an extended rasterizer state, with a corresponding description structure that has new members:</p>
<pre tabindex="0"><code>NvU32 ForcedSampleCount;
bool ProgrammableSamplePositionsEnable;
bool InterleavedSamplingEnable;
NvU8 SampleCount;
NvU8 SamplePositionsX[16];
NvU8 SamplePositionsY[16];
bool ConservativeRasterEnable;
NVAPI_QUAD_FILLMODE QuadFillMode;
bool PostZCoverageEnable;
bool CoverageToColorEnable;
NvU8 CoverageToColorRTIndex;
NvU32 reserved[16];
</code></pre><p>There&rsquo;s a few other goodies in there (like conservative rasterization, and Post-Z coverage!), but the members that we&rsquo;re concerned with are <strong>ProgrammableSamplePositionsEnable</strong>, <strong>InterleavedSamplingEnable</strong>, <strong>SampleCount</strong>, <strong>SamplePositionsX</strong>, and <strong>SamplePositionsY</strong>. <strong>ProgrammableSamplePositionsEnable</strong> is self-explanatory: it enables the functionality. <strong>SampleCount</strong> is also pretty obvious: it&rsquo;s the MSAA sample count that we&rsquo;re using for rendering. <strong>SamplePositionsX</strong> and <strong>SamplePositionsY</strong> are pretty clear in terms of what they&rsquo;re used for: they&rsquo;re for specifying the X and Y coordinates of our MSAA sample points. What&rsquo;s not clear at all is how the API interprets those values. My initial guess was that they should contain 8-bit fixed point numbers where (0,0) is the top left of the pixel, and (255,255) is the bottom right. This was close, but not quite: they&rsquo;re actually 4-bit fixed-point values that correspond to points in the D3D Sample Coordinate System. If you&rsquo;re not familiar with this particular coordinate system (and you&rsquo;re probably not), there&rsquo;s a nice diagram in the documentation for the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/Ff476218(v=VS.85).aspx">D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS enumeration</a>[2]<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>:</p>
<p><a href="/images/converted/programmable-sample-points/d3d-sample-coordinate-system.png"><img src="/images/converted/programmable-sample-points/d3d-sample-coordinate-system.png" alt="D3D Sample Coordinate System"></a></p>
<p>There&rsquo;s also a bit more information in the documentation for <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471396(v=vs.85).aspx">EvaluateAttributeSnapped</a>:</p>
<pre tabindex="0"><code>Only the least significant 4 bits of the first two components (U, V) of the pixel offset are used.
The conversion from the 4-bit fixed point to float is as follows (MSB...LSB),
where the MSB is both a part of the fraction and determines the sign:

1000 = -0.5f (-8 / 16)
1001 = -0.4375f (-7 / 16)
1010 = -0.375f (-6 / 16)
1011 = -0.3125f (-5 / 16)
1100 = -0.25f (-4 / 16)
1101 = -0.1875f (-3 / 16)
1110 = -0.125f (-2 / 16)
1111 = -0.0625f (-1 / 16)
0000 = 0.0f ( 0 / 16)
0001 = 0.0625f ( 1 / 16)
0010 = 0.125f ( 2 / 16)
0011 = 0.1875f ( 3 / 16)
0100 = 0.25f ( 4 / 16)
0101 = 0.3125f ( 5 / 16)
0110 = 0.375f ( 6 / 16)
0111 = 0.4375f ( 7 / 16)
</code></pre><p>So basically we have 16 buckets work with in X and Y, with the ability to have sample points sit on the top or left edges, but not on the bottom or right edges. Now as for the NVAPI extension, it uses this same coordinate system, except that all values or positive. This means that there is no sign bit, as in the values passed to EvaluateAttributeSnapped. Instead you can picture the coordinate system as ranging from 0 to 15, with 8 (0.5) corresponding to the center of the pixel:</p>
<p><a href="/images/converted/programmable-sample-points/nvapi-sample-grid1.png"><img src="/images/converted/programmable-sample-points/nvapi-sample-grid1_resized_620.png" alt="NVAPI Sample Grid"></a></p>
<p>Personally I like this coordinate system better, since having the pixel center at 0.5 is consistent with the coordinate system used for pixel shader positions and UV coordinates. It also means that going from a [0, 1] float to the fixed point representation is pretty simple:</p>
<pre tabindex="0"><code>rsDesc.SamplePositionsX[i] = uint8(Clamp(SamplePositions1x[i].x * 16.0f, 0.0f, 15.0f));
</code></pre><p>Now, what about that <strong>InterleavedSamplingEnable</strong> member that&rsquo;s also part of the struct? This is a somewhat poorly-named parameter that controls whether you&rsquo;re specifying the same sample positions for all 4 pixels in a 2x2 quad, or whether you&rsquo;re specifying separate sample positions for each quad pixel. The API works such that the first N points correspond to the top left pixel, the next N correspond to the top right pixel, then the bottom left, followed by the bottom right. This means that for 2xMSAA you need to specify 8 coordinates, and for 4xMSAA you need  to specify 16 coordinates. For 8xMSAA we would need to specify 32 coordinates, but unfortunately NVAPI only lets us specify 16 values. In this case, the 16 values correspond to the sample points in the top left and bottom left pixels of the quad.</p>
<h2 id="case-study-low-resolution-rendering">Case Study: Low-Resolution Rendering<a href="#case-study-low-resolution-rendering" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>So now that we have programmable sample points, what exactly should we do with them? MFAA-style temporal jittering is a pretty obvious use case, but surely there&rsquo;s other ways to make use of this functionality. One idea I&rsquo;ve been kicking around has been to use MSAA as way to implement half-resolution rendering. Rendering particles at half resolution is really common in games, since blending many layers of particles can result in high costs from pixel shading and framebuffer operations. It can be an easy win in many cases, as long as the content you&rsquo;re rendering won&rsquo;t suffer too much from being shaded at half-rate and upsampled to full resolution. The main issue of course is that you can&rsquo;t just naively upsample the result, since the half-resolution rasterization and depth testing will cause noticeably incorrect results around areas where the transparent geometry was occluded by opaque geometry. Here&rsquo;s a comparison between half-resolution particle rendering with a naive bilinear upscale (left), and full-resolution rendering (right):</p>
<p><a href="/images/converted/programmable-sample-points/lowres_naive_comparison.png"><img src="/images/converted/programmable-sample-points/lowres_naive_comparison_resized_620.png" alt="LowRes_Naive_Comparison"></a></p>
<p>Notice how in some areas the low-resolution buffer has false occlusion, causing no particles to be visible for those pixels, while in other places the particles bleed onto the foreground geometry even though they should have been occluded. Perhaps the most obvious and common way to reduce these artifacts is to use some variation of a bilateral filter during the upscale, where the filtering weights are adjusted for pixels based on the difference between the low-resolution depth buffer and the full-resolution depth buffer. The idea behind doing this is that you&rsquo;re going to have under or over-occlusion artifacts in places where the low-resolution depth is a poor representation of your full-resolution depth, and so you should reject low-resolution samples where the depth values are divergent. For The Order: 1886, we used a variant of this approach called nearest-depth upsampling, which was originally presented in an Nvidia SDK sample called <a href="http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/OpacityMappingSDKWhitePaper.pdf">OpacityMapping</a>. This particular algorithm requires that you sample 4 low-resolution depth samples from a 2x2 bilinear footprint, and compare each one with the full-resolution depth value. If the depth values are all within a user-defined threshold, the low-resolution color target is bilinearly upsampled with no special weighting. However if any of the sample comparisons are greater than the treshold value, then the algorithm falls back to using only the low-resolution sample where the depth value was closest to the full-resolution depth value (hence the name &ldquo;nearest-depth&rdquo;). Overall the technique works pretty well, and in most cases it can avoid usual occlusion artifacts that are typical of low-resolution rendering. It can even be used in conjunction with MSAA, as long as you&rsquo;re willing to run the filter for every subsample in the depth buffer. However it does have a few issues that we ran into over the course of development, and most of them stem from using depth buffer comparisons as a heuristic for occlusion changes in the transparent rendering. Before I list them, here&rsquo;s an image that you can use to follow along (click for full resolution):</p>
<p><a href="/images/converted/programmable-sample-points/nearestdepth_artifacts.png"><img src="/images/converted/programmable-sample-points/nearestdepth_artifacts_resized_620.png" alt="NearestDepth_Artifacts"></a></p>
<p>The first issue, illustrated in the top left corner, occurs when there are rapid changes in the depth buffer but no actual changes in the particle occlusion. In that image all of the particles are actually in front of the opaque geometry, and yet the nearest-depth algorithm still switches to point sampling due to depth buffer changes. It&rsquo;s very noticeable in the pixels that overlap with the blue wall to the left. In this area there&rsquo;s not even a discontinuity in the depth buffer, it&rsquo;s just that the depth is changing quickly due to the oblique angle at which the wall is being viewed. The second issue, shown in the top right corner, is that the depth buffer contains no information about the actual edges of the triangles that were rasterized into the low-resolution render target. In this image I turned off the particle texture and disabled billboarding the quad towards the camera, and as a result you can clearly see the a blurry, half-resolution stair-step pattern at the quad edges. The third issue, shown in the bottom left, occurs when alpha-to-coverage is used to get sub-pixel transparency. In this image 2xMSAA is used, and the grid mesh (the grey parallel lines) is only being rendered to the first subsample, which was done by outputting a custom coverage mask from the pixel shader. This interacts poorly with the nearest-depth upsampling, since 1 of the 2 high-res samples won&rsquo;t have the depth from the grid mesh. This causes blocky artifacts to occur for the second subsample. Finally, in the bottom right we have what was the most noticable issue for me personally: if the geometry is too small to be captured by the low-resolution depth buffer, then the upsample just fails completely. In practice this manifests as entire portions of the thin mesh &ldquo;disappearing&rdquo;, since they don&rsquo;t correctly occlude the low-resolution transparents.</p>
<h2 id="ramble-on">Ramble On<a href="#ramble-on" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>By now I hope you get the point: bilateral upsampling has issues for low resolution rendering. So how can we use MSAA and custom sampling points to do a better job? If you think about it, MSAA is actually perfect for what we want to accomplish: it causes the rasterizer and the depth test to run at a higher resolution than the render target(s), but the pixel shader still executes once per pixel. So if we use a half-resolution render target combined with 4x MSAA, then we should get exactly what we want: full-resolution coverage and depth testing, but half-resolution shading! This actually isn&rsquo;t a new idea: Capcom tried a variant of this approach for the original Lost Planet on Xbox 360. For their implementation, which is outlined <a href="http://game.watch.impress.co.jp/docs/20070131/3dlp.htm">here</a> in Japanese (English translation <a href="https://forum.beyond3d.com/threads/capcoms-framework-game-engine.31090/page-6#post-815108">here</a>), they were actually able to just alias their full-resolution render targets as a half-resolution 4xMSAA render targets while they were still in eDRAM. This worked for them, although at the time it was specific to the Xbox 360 hardware and also had no filtering applied to the low-resolution result (due to there being no explicit upscaling step). However we now have much more flexible GPU&rsquo;s that give us generalized access to MSAA data, and my hunch was that we could improve upon this by using a more traditional &ldquo;render in low-res and then upscale&rdquo; approach. So I went ahead and implemented a sample program that demonstrates the technique, and so far it seems to actually work! I did have to work my way past a few issues, and so I&rsquo;d like to go over the details in this article.</p>
<p>Here&rsquo;s how the rendering steps were laid out every frame:</p>
<ol>
<li>Render Shadows</li>
<li>Render Opaques (full res)</li>
<li>Run pixel shader to convert from full-res depth to 4xMSAA depth</li>
<li>Render particles at low-res with 4xMSAA, using ordered grid sample points</li>
<li>Resolve low-res MSAA render target</li>
<li>Upscale and composite low-res render target onto the full-res render target</li>
</ol>
<p>The first two steps are completely normal, and don&rsquo;t need explaining. For step #3, I used a full-screen pixel shader that only output SV_Depth, and executed at per-sample frequency. Its job was to look at the current subsample being shaded (provided by SV_SampleIndex), and use that to figure out which full-res depth pixel to sample from. The idea here is that 4 full-res depth samples need to be crammed into the 4 subsamples of the low-resolution depth buffer, so that all of the full-resolution depth values are fully represented in the low-res depth buffer:</p>
<p><a href="/images/converted/programmable-sample-points/fullres_halfres_samplepoints.png"><img src="/images/converted/programmable-sample-points/fullres_halfres_samplepoints_resized_620.png" alt="FullRes_HalfRes_SamplePoints"></a></p>
<p>If you look at the image, you&rsquo;ll notice that the MSAA sample positions in the low-resolution render target are spaced out in a uniform grid, instead of the typical rotated grid pattern. This is where programmable sample points come in: by manually specifying the sample points, we can make sure that  the low-resolution MSAA samples correspond to the exact same location as they would be in the full-resolution render target. This is important if you want your low-resolution triangle edges to look the same as if they would if rasterized at full resolution, and also ensures correct depth testing at intersections with opaque geometry.</p>
<p>For step #4, we now render our transparent geometry to the half-resolution 4xMSAA render target. This is fairly straightforward, and in my implementation I just render a bunch of lit, billboarded particles with alpha blending. This is also where I apply the NVAPI rasterizer state containing the custom sample points, since this step is where rasterization and depth testing occurs. In my sample app you can toggle the programmable sample points on and off to see the effect (or rather, you can if you&rsquo;re running on a GPU that supports it), although you probably wouldn&rsquo;t notice anything with the default rendering settings. The issues are most noticable with albedo maps and billboarding disabled, which lets you see the triangle edges very clearly. If you look at pair of the images below, the image to left shows what happens when rasterizing with the 4x rotated grid pattern. The image on the right shows what it looks like when using our custom sample points, which are in a sub-pixel ordered grid pattern.</p>
<p><a href="/images/converted/programmable-sample-points/edgesamplingcomparison.png"><img src="/images/converted/programmable-sample-points/edgesamplingcomparison_resized_620.png" alt="EdgeSamplingComparison"></a></p>
<p>For step #5, I use a custom resolve shader instead of the standard hardware resolve. I did this so that I can look at the 4 subsamples, and find cases where the subsamples are not all the same. When this happens, this means that there was a sub-pixel edge during rasterization, that was either caused by a transparent triangle edge or by the depth test failing. For these pixels I output a special sentinel value of -FP16Max, so that the upscale/composite step has knowledge of the sub-pixel edge.</p>
<p>In the last step, I run another full-screen pixel shader that samples the low-resolution render target and blends it on top of the full-resolution render target. The important part of this step is choosing how exactly to filter when upsampling. If we just use plain bilinear filtering, the results will be smooth but the transparents will incorrectly bleed over onto occluding opaque pixels. If we instead use the MSAA render target and just load the single subsample that corresponds to the pixel being shaded, the results will look &ldquo;blocky&rdquo; due to the point sampling. So we must choose between filtering and point sampling, just as we did with nearest-depth upsampling. In the resolve step we already detected sub-pixel edges, and so we can already use that to determine when to switch to point sampling. This gets us most of the way there, but not all of the way. For bilinear filtering we&rsquo;re going to sample a 2x2 neighborhood from the low-resolution texture, but our resolve step only detected edges within a single pixel. This means that if there&rsquo;s an edge between two adjacent low-resolution pixels, then we&rsquo;ll get a bleeding artifact if we sample across that edge. To show you what I mean, here&rsquo;s an image showing low-resolution MSAA on the left, and full-resolution rendering on the right:</p>
<p><a href="/images/converted/programmable-sample-points/msaa_edgebleed.png"><img src="/images/converted/programmable-sample-points/msaa_edgebleed_resized_620.png" alt="MSAA_EdgeBleed"></a></p>
<p>To detect this particular case, I decided to use an alpha comparison as a heuristic for changes in occlusion:</p>
<pre tabindex="0"><code>float4 msaaResult = LowResTextureMSAA.Load(lowResPos, lowResSampleIdx);
float4 filteredResult = LowResTexture.SampleLevel(LinearSampler, UV, 0.0f);
float4 result = filteredResult;
if(msaaResult.a - filteredResult.a &gt; CompositeSubPixelThreshold)
    result = msaaResult;
</code></pre><p>This worked out pretty nicely, since it essentially let me roll the two tests into one: if the resolve sub-pixel test failed then it would output -FP16Max, which automatically results in a very large difference during the edge test in the composite step. Here&rsquo;s an image where the left side shows low-resolution MSAA rendering with the improved edge detection, and the right side shows the &ldquo;edge&rdquo; pixels by coloring them bright green:</p>
<p><a href="/images/converted/programmable-sample-points/msaaedges.png"><img src="/images/converted/programmable-sample-points/msaaedges_resized_620.png" alt="MSAAEdges"></a></p>
<p>Before I show some results and comparisons, I&rsquo;d like to touch on integration with MSAA for full-resolution rendering. With nearest-depth upsampling, MSAA is typically handled by running the upsample algorithm for every MSAA sub-sample. This is pretty trivial to implement by running your pixel shader at per-sample frequency, which automatically happens if you use SV_SampleIndex as an input to your pixel shader. This works well for most cases, although it still doesn&rsquo;t help situations where sub-pixel features are completely missing in the low-resolution depth buffer. For the low-resolution MSAA technique that I&rsquo;m proposing it&rsquo;s also fairly trivial to integrate with 2x MSAA: you simply need to use 8xMSAA for your low-resolution rendering, and adjust your sample points so that you have 4 sets of 2x rotated grid patterns. Then during the upsample you can execute the pixel shader at per-sample frequency, and run the alpha comparison for each full-resolution subsample. Unfortunately we can&rsquo;t handle 4x so easily, since 16xMSAA is not available on any hardware that I know of. I haven&rsquo;t given it a lot of thought yet, but I think it should be doable with some quality loss by performing a bit of bilateral upsampling during the compositing step. On consoles it should also be possible to use EQAA with 16x coverage samples to get a little more information during the upsampling.</p>
<h2 id="results">Results<a href="#results" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>So now that we know that our MSAA trick can work for low-resolution rendering, how does it stack up against against techniques? In my sample app I also implemented full-resolution rendering as well as half-resolution with nearest-depth upsampling, and so we&rsquo;ll use those as a basis for comparison. Full resolution is useful as a &ldquo;ground truth&rdquo; for quality comparisons, while nearest-depth upsampling is a good baseline for performance. So without further adieu, here are some links to comparison images:</p>
<h3 id="normal">Normal<a href="#normal" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/standard_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/standard_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/standard_msaa.png">Low Res - MSAA</a></p>
<h3 id="sub-pixel-geo">Sub-Pixel Geo<a href="#sub-pixel-geo" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_msaa.png">Low Res - MSAA</a></p>
<h3 id="sub-pixel-geo--2x-msaa">Sub-Pixel Geo – 2x MSAA<a href="#sub-pixel-geo--2x-msaa" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_2x_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_2x_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/subpixelgeo_2x_msaa.png">Low Res - MSAA</a></p>
<h3 id="triangle-edges">Triangle Edges<a href="#triangle-edges" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/triangleedges_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/triangleedges_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/triangleedges_msaa.png">Low Res - MSAA</a></p>
<h3 id="high-depth-gradient">High Depth Gradient<a href="#high-depth-gradient" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/depthgradient_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/depthgradient_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/depthgradient_msaa.png">Low Res - MSAA</a></p>
<h3 id="alpha-to-coverage">Alpha To Coverage<a href="#alpha-to-coverage" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><a href="/images/converted/programmable-sample-points/a2c_fullres.png">Full Res</a></p>
<p><a href="/images/converted/programmable-sample-points/a2c_nearestdepth.png">Low Res - Nearest Depth</a></p>
<p><a href="/images/converted/programmable-sample-points/a2c_msaa.png">Low Res - MSAA</a></p>
<p>In my opinion, the quality is a consistent improvement over standard low-res rendering with a nearest-depth upscale. The low-resolution MSAA technique holds up in all of the failure cases that I mentioned earlier, and is still capable of providing filtered results in areas where the particles aren&rsquo;t being occluded (unlike the Lost Planet approach, which essentially upsampled with point filtering).</p>
<p>To evaluate performance, I gathered some GPU timings for each rendering step on my GeForce GTX 970. The GPU time was measured using timestamp queries, and I recorded the maximum time interval from the past 64 frames. These were all gathered while rendering at 1920x1080 resolution (which means 960x540 for half-resolution rendering) with 16 * 1024 particles, and no MSAA:</p>
<table>
<thead>
<tr>
<th>Render Mode</th>
<th>Depth Downscale</th>
<th>Particle Rendering</th>
<th>Resolve</th>
<th>Composite</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Res</td>
<td>N/A</td>
<td>4.59ms</td>
<td>N/A</td>
<td>N/A</td>
<td>4.59ms</td>
</tr>
<tr>
<td>Half Res – Nearest Depth</td>
<td>0.04ms</td>
<td>1.37ms</td>
<td>N/A</td>
<td>0.31ms</td>
<td>1.71ms</td>
</tr>
<tr>
<td>Half Res - MSAA</td>
<td>0.13ms</td>
<td>1.48ms</td>
<td>0.23ms</td>
<td>0.08ms</td>
<td>1.92ms</td>
</tr>
</tbody>
</table>
<p>On my hardware, the low-resolution MSAA technique holds up fairly well against the baseline of half-res with nearest depth upsampling. The resolve adds a bit of time, although that particular timestamp was rather erratic and so I&rsquo;m not 100% certain of its accuracy. One nice thing is that the composite step is now cheaper, since the shader is quite a bit simpler. In the interest of making sure that all of my cards are on the table, one thing that I should mention is that the particles in this sample don&rsquo;t sample the depth buffer in the pixel shader. This is common for implementing soft particles as well as for computing volumetric effects by marching along the view ray. In these cases the pixel shader performance would likely suffer if it had to point sample an MSAA depth buffer, and so it would probably make sense to prepare a 1x depth buffer during the downscale phase. This would add some additional cost to the low-resolution MSAA technique, and so I should probably consider adding it to the sample at some point.</p>
<p>These numbers were gathered with 2xMSAA used for full-resolution rendering:</p>
<table>
<thead>
<tr>
<th>Render Mode</th>
<th>Depth Downscale</th>
<th>Particle Rendering</th>
<th>Resolve</th>
<th>Composite</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full Res</td>
<td>N/A</td>
<td>4.69ms</td>
<td>N/A</td>
<td>N/A</td>
<td>4.69ms</td>
</tr>
<tr>
<td>Half Res – Nearest Depth</td>
<td>0.06ms</td>
<td>1.40ms</td>
<td>N/A</td>
<td>0.38ms</td>
<td>1.81ms</td>
</tr>
<tr>
<td>Half Res - MSAA</td>
<td>0.25ms</td>
<td>2.11ms</td>
<td>0.24ms</td>
<td>0.17ms</td>
<td>1.74ms</td>
</tr>
</tbody>
</table>
<p>Unfortunately the low-resolution MSAA technique doesn&rsquo;t hold up quite as well in this case. The particle rendering gets quite a bit more expensive, and the cost of downscale as well as the composite both increase. It does seem odd for the rendering cost to increase so much, and I&rsquo;m not sure that I can properly explain it. Perhaps there is a performance cliff when going from 4x to 8x MSAA on my particular GPU, or maybe there&rsquo;s a bug in my implementation.</p>
<h2 id="bring-it-on-home">Bring It On Home<a href="#bring-it-on-home" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>So what conclusions can we draw from all of this? At the very least, I would say that programmable sample points can certainly be useful, and that low-resolution MSAA is a potentially viable use case for the functionality. In hindsight it seems that my particular implementation isn&rsquo;t necessarily the best way to show off the improvement that you get from using programmable sample points, since the alpha-blended particles don&rsquo;t have any noticeable triangle edges by default. However it&rsquo;s definitely relevant if you want to consider more general transparent geometry, or perhaps even rendering opaque geometry at half resolution. Either way, I would really like to see broader support for the functionality being exposed in PC API&rsquo;s. Unfortunately it&rsquo;s not part of any Direct3D 12 feature set, so we&rsquo;re currently stuck with Nvidia&rsquo;s D3D11 or OpenGL extensions. It would be really great to see it get added to a future D3D12 revision, and have it be supported across Nvidia, Intel, and AMD hardware. Until that happens I suspect it will mostly get used by console developers.</p>
<p><em>Update: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt492660(v=vs.85).aspx">programmable sample point functionality was added to D3D12!</a></em></p>
<p>If you would like to check out the code for yourself, I&rsquo;ve posted it all on <a href="https://github.com/TheRealMJP/LowResRendering">GitHub</a>. If you&rsquo;d just like to download and run the pre-compiled executable, I&rsquo;ve also made a <a href="https://github.com/TheRealMJP/LowResRendering/releases">binary release</a> available for download. If you look through the build instructions, you&rsquo;ll notice that I didn&rsquo;t include the NVAPI headers and libs in the repository. I made this choice because of the ominous-sounding license terms that are included in the header files, as well as the agreement that you need to accept before downloading it. This means that the code won&rsquo;t compile by default unless you download NVAPI yourself, and place it in the appropriate directory. However if you just want to build it right away, there&rsquo;s a preprocessor macro called &ldquo;UseNVAPI_&rdquo; at the top of LowResRendering.cpp that you can set to 0. If you do that then it won&rsquo;t link against NVAPI, and the app will build without it. Of course if you do this, then you won&rsquo;t be able to use the programmable sample point feature in the sample app. The feature will also be disabled if you aren&rsquo;t running on a Maxwell 2.0 (or newer) Nvidia GPU, although everything else should work correctly on any hardware that supports FEATURE_LEVEL_11_0. Unfortunately I don&rsquo;t have any non-Nvidia hardware to test on, so please let me know if you run into any issues.</p>
<h2 id="references">References<a href="#references" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>[1] <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/Ff476218(v=VS.85).aspx">D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS enumeration</a> <br>
[2] <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff471396(v=vs.85).aspx">MSDN documentation for EvaluateAttributeSnapped</a> <br>
[3] <a href="http://www.geforce.com/hardware/technology/mfaa/technology">Multi-Frame Samples Anti-Aliasing (MFAA)</a> <br>
[4] <a href="http://www.cs.ubc.ca/~heidrich/Papers/RW.01_2.pdf">Interleaved Sampling</a> <br>
[5] <a href="https://developer.nvidia.com/sites/default/files/akamai/opengl/specs/GL_NV_sample_locations.txt">GL_NV_sample_locations</a> <br>
[6] <a href="https://developer.nvidia.com/nvapi">NVAPI</a> <br>
[7] <a href="http://advances.realtimerendering.com/s2014/drobot/HRAA_notes_final.pdf">Hybrid Reconstruction Anti-Aliasing</a> <br>
[8] <a href="http://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pptx">GPU-Driven Rendering Pipelines</a> <br>
[9] <a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/10/R6xx_3D_Registers.pdf">AMD R600 3D Registers</a> <br>
[10] <a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/10/SI_3D_registers.pdf">AMD Southern Islands 3D Registers</a> <br>
[11] <a href="https://www.opengl.org/registry/specs/AMD/sample_positions.txt">AMD_sample_positions</a> <br>
[12] <a href="http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/OpacityMappingSDKWhitePaper.pdf">OpacityMapping White Paper</a> <br>
[13] <a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch23.html">High-Speed, Off-Screen Particles (GPU Gems 3)</a> <br>
[14] <a href="http://game.watch.impress.co.jp/docs/20070131/3dlp.htm">Lost Planet Tech Overview</a> (<a href="https://forum.beyond3d.com/threads/capcoms-framework-game-engine.31090/page-6#post-815108">english translation</a>) <br>
[15] <a href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/ShopfMixedResolutionRendering.pdf">Mixed Resolution Rendering</a> <br>
[16] <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">Destiny: From Mythic Science Fiction to Rendering in Real-Time</a> <br></p>
<hr>
<h3 id="comments">Comments:<a href="#comments" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="heading"><a href="#heading" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p><a href="http://bartwronski.wordpress.com" title="elirian@gmail.com">bartwronski</a> - <time datetime="2015-09-13 21:39:47">Sep 0, 2015</time></p>
<p>Thanks for the post, very interesting! Cool that you covered use case for particles (description of temporal sample varying regular AA was done by Michal Drobot in his HRAA presentation). Can you answer if you used this on The Order 1886 (you mentioned during your Siggraph talk some console specific, NDA details), or is it all NDA&rsquo;d? I have a question about mention of soft particles and proposed solution: &ldquo;In these cases the pixel shader performance would likely suffer if it had to point sample an MSAA depth buffer, and so it would probably make sense to prepare a 1x depth buffer during the downscale phase.&rdquo; - I don&rsquo;t really understand what is this 1x depth buffer - regular full res buffer? Average depth buffer (reintroducing aliasing)? In any case it seems to me that soft particles have to run PS per subsample to get proper transparency ratio, or otherwise will reintroduce half res edges, do I understand correctly? Thanks again for the write up! BTW. picture msaaedges.png is not clickable like others - this is not a problem, but seems like it wasn&rsquo;t intended.</p>
<hr />
####
[]( "") - <time datetime="2015-09-15 12:40:02">Sep 2, 2015</time>
<p>Why resolve at all? With 4xMSAA, you have 4 color samples per low-res pixel, corresponding to the full-res pixel centers. Why throw them away, only to reconstruct during composite? I must be missing something.</p>
<hr />
####
[MJP](http://mynameismjp.wordpress.com/ "mpettineo@gmail.com") - <time datetime="2015-09-15 21:56:54">Sep 2, 2015</time>
<p>Hi Bart! Good to hear from you! I didn&rsquo;t use any of these techniques for The Order. After the game shipped I did integrate my own form of subsample jittering, so if that continues to work out then we will probably use it for the next project. Regarding the soft particles, I was suggesting to just use a point sampled 1/2 res depth buffer. Initially I had thought that it would be possible okay to do this as long as the fade was restricted to pixels that were in front of the opaque depth buffer value, but I thought about it some more and I realized that it would that this would still result in artifacts. So at the moment I don&rsquo;t have a good solution for handling soft particles or volumetrics, which is a really big downside. I&rsquo;ll have to think about it some more, and perhaps I can come up with approach that doesn&rsquo;t degenerate to shading for each subsample. Thank you for pointing out the missing link, it should be fixed now! @Anonymous - I don&rsquo;t &ldquo;throw away&rdquo; the subsamples, I still use them during the composite. The resolve step is to allow for bilinear filtering during the composite. If you just used the subsamples without filtering, you get correct edges but the result will look very &ldquo;blocky&rdquo; due to the point sampling (basically you get the same result as Lost Planet). But if you resolve the texture, then you can use bilinear filtering (or some other filter kernel) during the upscale in order to get better-looking results. Technically you could skip the resolve, and during the composite you could filter loading all subsamples for each pixel in the 2x2 filter footprint. But this would require 16 texture samples instead of just 1.</p>
<hr />
####
[AGraphicsGuy](http://agraphicsguy.wordpress.com "jerrycao_1985@icloud.com") - <time datetime="2015-12-06 20:00:28">Dec 0, 2015</time>
<p>Great blog. Just a heads-up, you can actually add &lsquo;read more tag&rsquo; after the first couple of paragraphs so that only part of your blog will be visible in the main page, instead of the full article.</p>
<hr />
####
[Beware of SV_Coverage &#8211; Yosoygames](http://www.yosoygames.com.ar/wp/2017/02/beware-of-sv_coverage/ "") - <time datetime="2017-02-28 11:50:23">Feb 2, 2017</time>
<p>[…] been obvious). Neither GL spec, docs, MSDN docs and other readings warned me about these gotchas. MJP’s blogposts were very useful, but that’s it. And they weren’t very specific to […]</p>
<hr />
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Some of you might remember ATI&rsquo;s old &ldquo;<a href="http://www.tweakguides.com/ATICAT_7.html">Temporal AA</a>&rdquo; feature from their Catalyst Control Panel, which had a similar approach to MFAA in that it alternated sample patterns every frame. However unlike MFAA, it just relied on display persistance to combine samples from adjacent frames, instead of explicitly combining them in a shader.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>If you&rsquo;ve been working with D3D11 for a long time and you don&rsquo;t recognize these diagrams, you&rsquo;re not going crazy. The original version of the D3D11 docs were completely missing all of this information, which actually made the &ldquo;standard&rdquo; MSAA patterns somewhat useless. <a href="/images/converted/programmable-sample-points/d3d11-smq-old.png">This</a> is what the docs for D3D11_STANDARD_MULTISAMPLE_QUALITY_LEVELS look like in the old DirectX SDK documentation, and <a href="/images/converted/programmable-sample-points/d3d11-eas-old.png">this</a> is what EvaluateAttributeSnapped looked like.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://therealmjp.github.io/tags/uncategorized">Uncategorized</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>5237 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2015-09-13 20:31 -0700</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://therealmjp.github.io/posts/update-for-my-shadow-sample-update/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>Update For My Shadow Sample Update</span>
			</a>
			<a class="prev-post" href="https://therealmjp.github.io/posts/siggraph-2015/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>SIGGRAPH Follow-Up: 2015 Edition</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://utteranc.es/client.js"
        repo="TheRealMJP/TheRealMJP.github.io"
        issue-term="title"
        label="comments"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2025 <a href="https://therealmjp.github.io/">MJP</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://therealmjp.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://therealmjp.github.io/js/main.min.6e4a8d6406e68b5f99eb4fd82c6e3eaa5aa471527d2d301aceaecdfefdd04bc9.js" integrity="sha256-bkqNZAbmi1+Z60/YLG4+qlqkcVJ9LTAazq7N/v3QS8k="></script>



</body>

</html>
