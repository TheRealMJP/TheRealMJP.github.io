<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="The Shader Permutation Problem - Part 2: How Do We Fix It?">
<meta itemprop="description" content="If you&#39;ve read the previous article then you hopefully have a decent understanding of how shader permutations ended up being such a common issue. The good news is that there is some hope for the future: if we look across recent game releases as well as the features available in the latest GPUs and APIs, we do see some promising avenues for digging ourselves out of our self-imposed avalanche of compiled bytecode.">
<meta itemprop="datePublished" content="2021-10-05T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2021-10-05T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="5589">
<meta itemprop="image" content="https://therealmjp.github.io/images/shaders/compiling_shaders.png">



<meta itemprop="keywords" content="Graphics,Shading," /><meta property="og:title" content="The Shader Permutation Problem - Part 2: How Do We Fix It?" />
<meta property="og:description" content="If you&#39;ve read the previous article then you hopefully have a decent understanding of how shader permutations ended up being such a common issue. The good news is that there is some hope for the future: if we look across recent game releases as well as the features available in the latest GPUs and APIs, we do see some promising avenues for digging ourselves out of our self-imposed avalanche of compiled bytecode." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therealmjp.github.io/posts/shader-permutations-part2/" />
<meta property="og:image" content="https://therealmjp.github.io/images/shaders/compiling_shaders.png" />
<meta property="article:published_time" content="2021-10-05T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-10-05T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://therealmjp.github.io/images/shaders/compiling_shaders.png"/>

<meta name="twitter:title" content="The Shader Permutation Problem - Part 2: How Do We Fix It?"/>
<meta name="twitter:description" content="If you&#39;ve read the previous article then you hopefully have a decent understanding of how shader permutations ended up being such a common issue. The good news is that there is some hope for the future: if we look across recent game releases as well as the features available in the latest GPUs and APIs, we do see some promising avenues for digging ourselves out of our self-imposed avalanche of compiled bytecode."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>The Shader Permutation Problem - Part 2: How Do We Fix It?</title>
	<link rel="stylesheet" href="https://therealmjp.github.io/css/style.min.9ae64a8094d0d100100f0725503238784f798a59c57003700be4d8b0645124e9.css" integrity="sha256-muZKgJTQ0QAQDwclUDI4eE95ilnFcANwC+TYsGRRJOk=">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://therealmjp.github.io/">The Danger Zone</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://therealmjp.github.io/posts/">Posts</a>
				<a href="https://therealmjp.github.io/about/">About</a>
				<a href="https://therealmjp.github.io/publications/">Publications</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="img-btn" class="hdr-btn" title="Featured Image"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/TheRealMJP" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/mynameismjp" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="mailto:mpettineo@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://therealmjp.github.io/posts/">Posts</a></li>
			<li><a href="https://therealmjp.github.io/about/">About</a></li>
			<li><a href="https://therealmjp.github.io/publications/">Publications</a></li>
		</ul>
	</div>


	<div class="bg-img"></div>
	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Oct 5, 2021</span></div>
				<h1>The Shader Permutation Problem - Part 2: How Do We Fix It?</h1>
			</header>
			<div class="content">
				<p>If you've read the previous article then you hopefully have a decent understanding of how shader permutations ended up being such a common issue. The good news is that there is some hope for the future: if we look across recent game releases as well as the features available in the latest GPUs and APIs, we do see some promising avenues for digging ourselves out of our self-imposed avalanche of compiled bytecode. In my opinion nothing I'm going to mention here is a silver bullet on its own: each technique comes with a set of trade-offs to be carefully evaluated in the context of an engine and the games that run on it. Regardless, it's inspiring to see smart and resourceful people come up with clever approaches that help to sidestep some of the issues that I've brought up the previous article.</p>

<h3 id="only-compile-what-you-need">Only Compile What You Need<a href="#only-compile-what-you-need" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<!---
TODO: Get LE2 shader/PSO info
-->

<p>This is the simplest, oldest, and perhaps least-effective way to reduce permutation counts. The general idea is that out of your 2^N possible permutations, some subset of them are either redundant, invalid, or will never actually get used. Therefore you will reduce the set of shaders that you need to compile and load if you can strip out the unnecessary permutations. In many cases the reduction in shader permutation count can be substantial, and can be the difference between &quot;completely untenable&quot; and &quot;we can ship this&quot;. Ideally this process is something you would do offline, perhaps as part of a content processing pipeline that has knowledge of what meshes and materials are going to be used in each scene. But there have also been games/engines that have done it at runtime, essentially deferring compilation of a permutation until the scene is loaded. Either way there are some pretty obvious downsides:</p>

<ul>
<li>Determining your set of shaders offline requires your offline process to have a pretty complete understanding of both the content and how it interacts with your shader pipeline. Making changes to how that works may also require you to re-compile and invoke the content processing pipeline again, as opposed to re-compiling the runtime code and running the app again</li>
<li>Offline approaches may make editors and other tooling more complicated, since you now have to deal with an on-the-fly combination of mesh + material</li>
<li>On a related note, some engines are setup where they treat their shaders more like code and less like content. For instance, they might want to compile shaders using the same build system used for C++ code since it already handles dependencies and includes correctly. Moving to a system where the shaders are compiled as part of the content pipeline can potentially be a large shift.</li>
<li>If you wait until runtime to compile your shaders, you now have to either make the user wait for compilation to complete or do something else to hide the compilation time. This might involve having QA generate a cache of shaders to ship with the game, or it might even involve <a href="https://dolphin-emu.org/blog/2017/07/30/ubershaders/">using a slow and generic shader until your specialized permutation finishes compiling in the background</a>. Platforms that don't allow you to invoke the shader compiler at runtime can also make this approach a non-starter, at least without some kind of two-step process that discovers the shaders and then compiles an offline cache to ship with the app.</li>
<li>The amount of shaders that you generate is content-dependent, and the count could vary wildly depending on the scene/game/material setup/etc.</li>
<li>In the worst case this degenerates to compiling your full set of permutations, except that you may end up with a more complicated pipeline for generating those permutations.</li>
<li>It doesn't do anything to reduce your loaded shader/PSO count at runtime. If you need to rely on a small number of PSOs to implement some technique (for example, GPU-driven rendering) then this approach won't help you.</li>
</ul>

<p>For our engine at Ready At Dawn, we have used the offline variant of this approach with some success. When our content processing pipeline encounters a mesh, it looks at the assigned material as well as properties of the mesh itself to figure out the final shader permutation that will be required. A request to compile that shader is then kicked off, and the final bytecode is ready to load in the game. In our case the reduction is quite substantial: just our &quot;generic&quot; base material + shader set supports an unfathomable number of possible permutations, and the vast majority go unused. For Lone Echo 2 we end up compiling around XXX pixel shaders out of a possible set of over YYY, and typically have around ZZZ PSOs loaded at runtime. Unfortunately the full set of shaders to compile is still quite large, so a global change can take quite some time to churn through before the full game is rebuilt. To mitigate this we make use of distributed shader compilation that is run on idle machines. One silver lining is that it's quite simple to build only the set of shaders required for a particular area of the game, since the shaders are compiled as part of processing a particular chunk of the game world. This can make iteration times lower for global shader changes, but still quite far from instant. To handle tooling issues where the mesh + material combination is not known at runtime, we use &quot;generic&quot; un-permuted versions of our shaders that branch on constant buffer values for all features. As a bonus these shaders also support full real-time parameter editing, and have additional dev-only features for debugging. These shaders are <em>huge</em> though since they support every possible feature, and can be quite slow!</p>

<h3 id="runtime-specialization">Run-Time Specialization<a href="#runtime-specialization" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p><a href="https://www.khronos.org/registry/vulkan/specs/1.1-khr-extensions/html/chap10.html#pipelines-specialization-constants">Vulkan</a> and <a href="https://developer.apple.com/documentation/metal/using_function_specialization_to_build_pipeline_variants">Metal</a> both support an interesting feature called <em>specialization constants</em>, or &quot;spec constants&quot; for short (Metal calls the feature &quot;function specialization&quot;). The basic idea goes like this:</p>

<ul>
<li>You compile your shader with a global uniform value (basically like a value in a constant buffer) that's used in your shader code</li>
<li>When creating the PSO, you pass a value for that uniform that will be constant for all draws and dispatches using the PSO</li>
<li>The driver somehow ensures that the value you passed is used in the shader program. This might include:

<ul>
<li>Treating the value as a &quot;push constant&quot;, basically a small uniform/constant buffer that gets set from the command buffer</li>
<li>Patching a value into the compiled intermediate bytecode or vendor-specific ISA</li>
<li>Treating the value as a compile-time constant when the driver does its JIT compile and performing full optimizations (including constant folding and dead code elimination) based on that value</li>
</ul></li>
</ul>

<p>It's a pretty neat concept, since it potentially lets you avoid having to do a lot of your own compiling and instead rely on the driver's backend compiler to do a lot of the work for you. If you have a lot of specializations it won't necessarily allow you to reduce your PSO count, but it can be pretty nice in a similar way to the &quot;Compile What You Need&quot; strategy if you don't use your full set of possible permutations at runtime. A good example is using them to implement quality levels based on user settings: you're not going to need both the low-quality and high-quality PSOs at once, so you can use a spec constant to choose when you create the PSO. It should be noted though that spec constants also share one of the main issues with &quot;Compile What You Need&quot;: it won't reduce your runtime PSO count. You can potentially ship and load fewer shader binaries which is an improvement, but you can still run into the same problems that PSOs can cause with batching and ray tracing.</p>

<p>The other main issue with this approach (aside from lack of support in D3D12 and consoles) is that you don't really know which approach the driver is going to take when it handles your spec constant. Sure it makes sense that it will dead-strip as much as it can since it's doing that as part of its JIT compile anyway, but drivers have complicated trade-offs to deal with when it comes to doing their back-end compilation. If they take too long when initially creating your PSO then games can have slow loading times, and both devs and customers will complain. Doing further optimization on a background thread is possible, but drivers are limited in how much of the CPU they can use for this (particularly in D3D12) and it surely makes things more complicated for both the driver and developer. The worst part is that you could end up having wildly varying results (and thefore performance) based on the vendor and driver version. Sure in some ways you just have to be zen about hoping that PC drivers will do whatever they need to in the background to make things fast, but do you really want to set up your entire shader pipeline on the assumption that you'll get as good results as if you compiled the shader permutations beforehand? Do you really want to that on mobile where drivers are even <em>more</em> constrained in their CPU usage?</p>

<p>One interesting variant on this approach could be to have the app manually invoke the shader compiler (or some slimmed-down version of it) to patch in the spec constant and optimize based on its value. I'm not sure if this would be significantly faster than invoking the full compiler toolchain again, but perhaps it could be speedier since you wouldn't need to parse anything. This approach would work on any API as long as the compiler can run on-target, and you would have the peace of mind of knowing that the optimization and dead-stripping is for sure happening. It would also put any trade-offs regarding background compilation in the hands of the app developers, which would certainly be more consistent with the overall spirit of the &quot;explicit&quot; APIs.</p>

<h3 id="cached-material-evaluation">Cached Material Evaluation<a href="#cached-material-evaluation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>A lot of what goes into our shader permutations is typically related to combining and building shading parameters in various ways. It's quite common to build the &quot;look&quot; of one material by sampling multiple textures with different UV values, either to add varying levels of detail or to create meta-materials from simpler &quot;building blocks&quot;. A broad feature set for doing these operations can naturally result in a lot of shader code, which can in turn lead to shader permutations. Or alternatively an engine might allow technical artists to completely define their own logic by authoring shader graphs, in which case there are potentially unlimited numbers of compiled shaders that could be generated. If you can somehow pull this process out of your pixel shader, then you can perhaps reduce the number of shader variants that are needed for your draws. There are a few ways you might do this:</p>

<ul>
<li>Use Substance Designer or a <a href="https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf">custom material pipeline</a> to do offline compositing and generating of your textures

<ul>
<li>Even with this you generally still want to combine tiling maps together at runtime since &quot;flattening&quot; them would consume considerably more memory</li>
</ul></li>
<li>Use an offline system combined with runtime virtual texturing to full generate a unique set of composited textures for all surfaces in the game (basically the Megatexture approach)

<ul>
<li>There are plenty of well-documented issues with this approach, such as disk space, streaming/transcoding cost, lack of fine texture detail, etc.</li>
</ul></li>
<li>Use a runtime virtual texturing system that composites/generates pages on-the-fly

<ul>
<li>More complex, you may still need permutations for the process that does the VT page generation</li>
</ul></li>
</ul>

<p>The end goal of these techniques is to end up with simpler pixel shaders that can just sample one set of textures without needing to do anything fancy with them. This won't help you for the portions of the shader that <em>don't</em> deal with generating shading parameters, but it can potentially cut things down quite a bit.</p>

<h3 id="replace-permutations-with-branching-and-looping">Replace Permutations with Branching and Looping<a href="#replace-permutations-with-branching-and-looping" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>On modern GPUs flow control is <a href="https://bartwronski.com/2021/01/18/is-this-a-branch/">no longer the problem that it used to be</a>. Having divergent branching and looping within a wave is still a problem due to the SIMD execution model used on GPUs, but if all threads go down the same path it can be quite efficient. Therefore if you've got a material flag that enables a feature for an entire draw call, it could make a lot of sense to stick that value in a uniform/constant buffer and branch on it in the shader at runtime. This kind of branching is usually referred to as &quot;uniform branching&quot; or &quot;static branching&quot; since it guarantees that you're not going to have any divergence. The idea here is that we can rethink a lot of the permutation decisions that we made 10 years ago and (hopefully) reduce our total shader count after sprinkling in a lot of these static branches. If that branch is totally uniform then the shader process will legitimately skip over the instructions in the branch when the flag is disabled, and it may not even cost very many cycles to do this if the code has a dedicated scalar unit for performing those operations.</p>

<p>The poster child for this approach is the past two Doom games from id: <a href="http://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf">Doom 2016</a> and <a href="https://advances.realtimerendering.com/s2020/RenderingDoomEternal.pdf">Doom: Eternal</a>. In their presentations they mention that they use a forward-rendering ubershader that only results in ~100 shaders and ~350 PSOs. This is of course more than a handful but a distributed compilation system can probably tear through that many shaders in no time, making it very attractive from an iteration point of view. Personally I get quite jealous when thinking of how much simpler my life would be with only that many shaders to deal with, and I really doubt I'm the only one! Their games run really well and look great so it's a pretty strong proof-of-concept that this approach can work.</p>

<p>With that said, I personally still think it can be quite difficult to achieve a low permutation count in the general case. In <a href="../shader-permutations-part1">part 1</a> we discussed why this is tricky to get right, so I won't go into detail again. But the main gist of it is that it can be difficult to know where you should leave a branch or loop and where you should permute/unroll. On consoles you can make pretty informed decisions by looking at a single GPU in isolation (and make use of the excellent tooling), but on PC and mobile you are in a much much tougher spot. But on the positive side having fewer permutations means fewer total programs to optimize by hand, which can potentially pay off in big ways. In particular it's a lot more reasonable to try to make sure that all of your permutations have a reasonable register count and occupancy...at least assuming that you have the tools available to determine these things.</p>

<p>I think what would truly help in using this approach is to have a lot of discipline and focus in your material/shader feature set. The less features you need to support, the easier it's going to be to make sensible decisions about where you should permute. I would imagine you would have to get used to saying &quot;no&quot; to a lot of feature requests, since every feature added can potentially affect the performance of your ordinary baseline materials unless it's gated behind a permutation. For those of us with very broad material feature sets it seems difficult to get to that point without being very disruptive to existing workflows, and/or without giving up things that make significant contribution to the look of a game.</p>

<p>Another thing that could really help is good automated processes for helping to figure out which permutations are truly worth it vs. just leaving in a branch. Unfortunately the testing space for this is quite large: you can have N different materials and M different video cards with a huge amount of permutation options, so it's not feasible to test exhaustively. But perhaps reasonable subsets can be derived that give a decent level of confidence.</p>

<p>One last thing I would like to note is that you have to watch out for drivers silently taking your handful of shaders and permuting them behind your back. At least in D3D11 this was something that was known to happen: the driver would look at your constant buffer and use the values to flatten branches and unroll loops behind your back. This can lead you to think that your shaders are well-optimized...until you run them on a driver that <em>doesn't</em> do this and the performance is bad. I don't think think drivers can realistically do this anymore in D3D12 and Vulkan since they're much more explicit about how PSOs and shaders work, but I don't think I can rule it out completely if they're sufficiently motivated.</p>

<h3 id="deferred-rendering-and-other-techniques-for-splitting-up-shading">Deferred Rendering, and Other Techniques For Splitting Up Shading<a href="#deferred-rendering-and-other-techniques-for-splitting-up-shading" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>When people first learn about deferred rendering, there's usually a lot of focus on how it helps to achieve greater dynamic lighting counts by decoupling the lighting process from your geometry. While this was true at the time it became popular, IMO the real secret weapon of deferred is that it's a way of chopping up a mesh's rendering process into at least two different distinct phases. In effect this is really a way of <em>modularizing</em> your shader code, despite the fact that invididual shader programs are still monolithic. You can conceptually think of most deferred techniques as splitting up a single gigantic pixel shader function into two separate functions: one that calculates the parameters that feed into the lighting phase (surface normals, albedo, roughness, etc.) and another that takes those parameters and computes how much light reflects off the surface given a collection of lighting sources. With this mental model you can even think of the G-Buffer as being a sort of &quot;ABI&quot; that allows your first phase to pass its arguments to the second, except in this case it does so by writing out many megabytes of per-pixel data to a collection of render target textures.</p>

<p>The effect on permutation count can be significant, since it effectively causes us to split our pixel shader into two feature groups instead of one. Let's see what our permutated pixel shader from part 1 looks like before and after converting to deferred:</p>

<p><span  class="math">\[ PShader(NormalMap[Off, On] * LightType[Point, Spot, Area] * Shadows[Off, On]) \]</span></p>

<p><span  class="math">\[ GBuffer(NormalMap[Off, On]) + Lighting(LightType[Point, Spot, Area] * Shadows[Off, On]) \]</span></p>

<p>Splitting up our shader turned one of those multiplies into an add, causing us to drop from 12 pixel shader permuations down to 8. Saving 4 shaders might not sound like a lot, but keep in mind the delta can be <em>significantly</em> larger as the number of features grow. In practice this can be a huge win for permutation counts, and the modularization can have all kinds of other halo effects. For example you can potentially optimize the code for your G-Buffer and Lighting phases separately without having to consider interactions, and the peak register usage will often be lower as a result of splitting things into smaller shaders with fewer steps. Shader compilers may also be able to chew threw your shaders more quickly since they are smaller, since optimization time can grow non-linearly with code length.</p>

<p>In practice there <a href="https://software.intel.com/content/www/us/en/develop/articles/deferred-rendering-for-current-and-future-rendering-pipelines.html">all</a> <a href="http://jcgt.org/published/0002/02/04/">kinds</a> of <a href="https://therealmjp.github.io/posts/bindless-texturing-for-deferred-rendering-and-decals/">flavors</a> of <a href="http://filmicworlds.com/blog/visibility-buffer-rendering-with-material-graphs/">deferred</a>, and even more ways of splitting things up the final rendering pipeline into separate phases with distinct shader programs. For instance, it's completely possible to only pull out shadow map evaluation into its own deferred passes that only requires a depth buffer, while keeping everything else in a combined forward pixel shader. Or going in the other direction, with deferred you have the option to either do all lighting in a single combined draw or dispatch, vs. further splitting the lighting passes into multiple sub-steps. Doing 1 pass per light source can allow for trivial shader specialization based on the properties of the light source while avoiding combinatorial issues, while doing separate passes for things like sampling ambient diffuse lighting can also provide opportunities for using async compute.</p>

<p>But of course, everything is a trade-off. One thing that most deferred renderers need to do at some point in the frame is write out results to memory and then read them back into registers<sup class="footnote-ref" id="fnref:1"><a class="footnote" href="#fn:1">1</a></sup>. In the more classic deferred setups this happens when the G-Buffer is written out to render target textures, and then gets read back in during a lighting pass. If you were to compare that to a modern forward renderer you would likely see that the &quot;G-Buffer&quot; still exists in the forward pipeline, it just ends up sitting in registers that store the values passed between two phases of the same shader program. When you think about things in those terms deferred might not sound so appealing! After all, isn't it better to keep data in ultra-fast registers rather than spilling them out to memory and then reading them back in again? But of course things are much more complicated than that when it comes to performance and renderer design, as we discussed in part 1 when we talked about taking a global approach to GPU performance. Perhaps using more bandwidth and memory ends up being a net negative, or perhaps the shorter/higher-occupancy shader programs enabled by modularization win out in the end. Perhaps letting the compiler optimize across a giant forward pixel shader enables some serious wins, or perhaps the I$ misses add up and limit your performance. Or perhaps you end up designing your deferred renderer in a way such that you can analyze the properties of your G-Buffer on per-tile basis, and use that analysis to manually propogate optimizations into the deferred shader, thus gaining back many of the benefits that the compiler's optimizer might have afforded you. Or maybe your forward renderer completely dies due to pixel shader quad overdraw caused by tiny triangles, whereas the deferred renderer handles it more gracefully. It's clearly not a straighforward proposition, and the continued success of deferred certainly suggests that it can win out in many cases.</p>

<h3 id="offline-linking">Offline Linking<a href="#offline-linking" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>In part 1 we discussed how the monolithic shader compilation model contributed to permutation explosions. If you can't compile and optimize portions of a shader program individually, then permututations that only affect that portion end up requiring the entire program to be re-compiled. What if there was some hot new technology from the 1970's that would let us compile separate binaries and then &quot;link&quot; them together into one combined shader program? That would be be pretty neat, right? 😉</p>

<p>The good news is that DXIL and SPIR-V support this sort of thing! For D3D12/DXIL all of the functionality to compile and link libraries is present in <a href="https://github.com/microsoft/DirectXShaderCompiler">dxc</a>, either via the command line or through its API. See my <a href="../dxil-linking">recent post about it</a> for more details on how it works in practice. The story for SPIR-V though is a little more complicated. <a href="https://github.com/KhronosGroup/SPIRV-Tools">SPIR-V Tools</a> has a utility for doing the linking, provided you have some compiled SPIR-V that's been generated with the appropriate <a href="https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html#Linkage_Type">linkage type</a>. At the time of writing however, neither dxc nor glslang are capable of generating SPIR-V with the appropriate declarations. Therefore if you want to write HLSL or GLSL and link the results together, there doesn't seem to be a working option for doing that. However I've been told that other projects that generate SPIR-V through other means (such as <a href="https://github.com/EmbarkStudios/rust-gpu">rust-gpu</a>) have been able to successfully link using the SPIR-V tools. Either way it's cool that in both cases the linking happens in open-source toolchains using documented IL representations. <sup class="footnote-ref" id="fnref:2"><a class="footnote" href="#fn:2">2</a></sup></p>

<p>There's a big question mark when it comes to linking: for compiling a zillion permutations, would it actually reduce the compile times? I don't have any data to draw even some basic conclusions from, so I think we'll have to wait for someone to do some more comprehensive testing. Ultimately the situation might not be straightforward depending on the inputs to compiling and linking. There's also the potential for a linking step to make the compilation pipeline more complicated, just like it does for C/C++. In particular it might convert what was once a straightforward parallel operation into a tree with dependencies and sync points.</p>

<p>The other thing that's both good and bad is that linking doesn't really change the runtime situation at all. Since the linking can happen fully offline and outside of the API, the API and driver don't really have to know or care that things were linked together (although there's always some possibility that linking generates new bytecode patterns that can cause drivers to choke). This means there's no need to wait for new API or driver support, which is a good thing. It also means there's no reason to expect a significant delta in performance between a linked and fully-compiled program, at least assuming there's a post-link optimization step (not doing one would introduce some interesting trade-offs). But it also means that it won't do anything to reduce the number of shaders and PSOs that have to loaded at runtime, which is not-so-great. Therefore it won't be a cure if your engine has a case of PSO-itis.</p>

<h3 id="true-function-calls-and-dynamic-dispatch">True Function Calls and Dynamic Dispatch<a href="#true-function-calls-and-dynamic-dispatch" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>Having a runtime function call combined with dynamic dispatch is potentially more interesting than a linking step, but it's also much more of a radical change. While linking can happen offline with no driver input, dynamic dispatch for sure requires the driver and the hardware to be on board. The &quot;stuff everything in a statically-allocated chunk of registers&quot; model used by most GPUs certainly doesn't lend itself to true dynamic dispatch, and it's easy to imagine that various constraints on the programming might be necessary to keep performance from falling off a cliff.</p>

<p>The good news is that on PC we sort-of have this right now! The bad news is that it's <em>very</em> constrained, and only works for ray tracing. I'm less familar with the specifics for Vulkan, but in <a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html">D3D12/DXR</a> it works by essentially having a sort of &quot;run-time linker&quot; step. Basically you compile a bunch of functions into a DXIL binary using a &quot;lib&quot; target (just like you would for offline linking), and then at runtime you assemble all of your pieces together into a combined state object. Later on when you call DispatchRays the driver is able to dynamically execute the right hit/miss/anyhit/etc. shader since it was linked into the state object. There <em>is</em> a <a href="https://microsoft.github.io/DirectX-Specs/d3d/Raytracing.html#callable-shaders">callable shaders feature</a> that can be used without any actual ray tracing, however it still needs to be used from within a ray generation shader that was kicked off from DispatchRays. In other words: it's usable right now for compute-like shaders, but currently can't be used within the graphics pipeline. With any luck this could change in the future! <sup class="footnote-ref" id="fnref:3"><a class="footnote" href="#fn:3">3</a></sup></p>

<p>Currently I'm not aware of anyone that has tried using DXR callable shaders to replace permutations, or at least that has published their findings. Personally I have not experimented with them, so I'm not yet sure how they might work out in practice. With that said, we can still probably make some reasonable assumptions based on what we know about how they work and what kind of implications they might have on usage and performance:</p>

<ul>
<li>They currently require a runtime &quot;link&quot; step where all possible callables are assembled into a single state object and associated shader table, either by creating a new one or by calling AddToStateObject to append additional shader binaries. This has implications on streaming, since loading in new callable shaders may require modifying a global state object being used for rendering. Either way you need to be careful where you interact with state objects since it can involve a JIT compile, just like creating a normal PSO.</li>
<li>We probably should not expect any magic workarounds for static register allocation: if a callable shader requires many registers, we can likely expect for the occupancy of the entire batch to suffer. It's possible that GPUs could diverge from this model in the future, but that could come with all kinds of potential pitfalls (it's not like they're going to start spilling to a stack when executing thousands of pixel shader waves).</li>
<li>The way the state object spec is setup gives drivers some room to do transformations if necessary. Since the full set of call targets is known when creating or modifing a state object, it's feasible that the driver might make make a decision to &quot;flatten&quot; a CallShader into a branch with inlined function calls.</li>
<li>There's some subtle implications depending on whether this kind of functionality is implemented as a function call from the same wave, or whether it implies that a wave is launched that runs the function being called. In particular the DXR model implies the latter, since hit shaders can set their own resource context and bindings via a local root signature. There can also be implications around how divergence is handled (different threads in the same wave calling different functions), and whether or not threads are allowed to be &quot;re-packed&quot; into a full wave. For replacing existing permutations I would expect the function calls to be completely uniform, and thus a simpler &quot;run the function in the same thread&quot; approach is sufficient and probably more desirable. Having a resource context is also not necessary as long as bindless is being used.</li>
</ul>

<p>We'll have to watch this area closely in the future. With any luck this kind of functionality can be extended to graphics pipelines and standard compute shaders, which could be a very compelling option for those of us that are juggling too many permutations. Metal is also currently ahead of the curve on this front, and already offers <a href="https://developer.apple.com/videos/play/wwdc2021/10229/">more generic function pointers</a> that can be called from any shader stage. Perhaps this can serve as inspiration for PC and Android!</p>

<h3 id="summary">Summary<a href="#summary" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<table>
<thead>
<tr>
<th>Technique</th>
<th>Pros</th>
<th>Cons</th>
<th>Platforms</th>
</tr>
</thead>

<tbody>
<tr>
<td>Compile What You Need</td>
<td>Less offline compiling, no changes needed to renderer</td>
<td>No reduction in PSOs, might not reduce shader count enough, may need offline analysis</td>
<td>Any</td>
</tr>

<tr>
<td>Run-Time Specialization</td>
<td>Significantly less offline compiling, no changes needed to renderer</td>
<td>May add to PSO creation time, driver might not optimize as much as you want</td>
<td>Vulkan, Metal</td>
</tr>

<tr>
<td>Cached Material Evaluation</td>
<td>Less offline compiling and lower PSO counts, could speed up GPU performance</td>
<td>Complex and potentially invasive to the renderer, only affects shading parameter generation</td>
<td>Any</td>
</tr>

<tr>
<td>Runtime Branching And Looping</td>
<td>Significantly less offline compiling and lower PSO counts</td>
<td>Potential performance implications, may put serious contraints on material features, no shader graphs</td>
<td>Any</td>
</tr>

<tr>
<td>Deferred Rendering</td>
<td>Less offline compiling and PSOs, more modular code, could be better for GPU performance</td>
<td>Very invasive to the renderer, may not be a good fit for certain hardware and use cases</td>
<td>Any</td>
</tr>

<tr>
<td>Offline Linking</td>
<td>Potentially quicker offline compiling, no changes needed to renderer</td>
<td>May not be faster to compile, doesn't reduce PSOs, may reduce GPU performance if not optimized post-link</td>
<td>D3D12, Vulkan, Metal</td>
</tr>

<tr>
<td>Dynamic Function Calls</td>
<td>Significantly less offline compiling and PSO counts, opens the door to other new techniques</td>
<td>Likely worse for GPU performance, requires changes to how your engine handles shaders and PSOs</td>
<td>D3D12 + Vulkan (Compute-Only), Metal (Full Support)</td>
</tr>
</tbody>
</table>

<h3 id="final-thoughts">Final Thoughts<a href="#final-thoughts" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>That's it for the series! I hope it was an enjoyable read, and that it helped to give some additional context regarding the ongoing battle against shader combinatorial explosion. Please leave a comment or reach out on Twitter if you have any additional thoughts or insights, or if you take issue with anything I've written here.</p>
<div class="footnotes">

<hr>

<ol>
<li id="fn:1">Many mobile GPUs have fast on-chip framebuffer memory that can be accessed through special mechanisms. This can allow deferred renderers to keep their G-Buffer entirely in on-chip memory rather than slower off-chip memory, potentially changing the trade-offs that are mentioned here.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">D3D11 and fxc actually added support for <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/using-shader-linking">offline linking</a> in the Win 8 era. Unfortunately it was rather complicated, and I'm not sure if it ever got heavy usage.
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:3">D3D11 actually launched with a psuedo-dynamic-linking feature that was called <a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/overviews-direct3d-11-hlsl-dynamic-linking">Dynamic Shader Linkage</a> in D3D11. It was a <a href="https://microsoft.github.io/DirectX-Specs/d3d/archive/D3D11_3_FunctionalSpec.htm#7.19.1%20Overview">noble effort</a>, and had some really interesting and forward-looking ideas. In particular it tried to save the developer from having to somehow know the right magic conditions for when to permute and when not to, and it did this by essentially kicking that decision up the driver. In order to do this though it had some pretty wacky syntax. Basically you would define interfaces with methods, and then declare N classes that implemented those interfaces and their methods. This let the offline compiler (fxc) figure out all the possibilities for what implementation might be invoked at each call site into an interface, and then it could present the driver's backend compiler with a pre-compiled set of possibilities for the callee with full optimization applied across the function boundary. At runtime you would then use some rather complicated APIs to choose which class implementation would ultimately get used when you bound a shader. In hindsight it's not too hard to see why this failed. The class/interface HLSL additions was quite a departure from previous shader code, and rendered it incompatible when trying to use it across platforms. It also doesn't really solve the issue of needing to compile N shaders, since that permutation loop was really just getting moved inside of the shader compiler (it wasn't actually compiling the class implementation methods separately). On top of that, it doesn't really guarantee that the driver won't just end up creating N full permutations of your shader program at runtime. This certainly would have been the easiest path forward for them, and may have been the best option for various reasons.
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
</ol>
</div>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://therealmjp.github.io/tags/graphics">Graphics</a></span><span class="tag"><a href="https://therealmjp.github.io/tags/shading">Shading</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>5589 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2021-10-04 17:00 -0700</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://therealmjp.github.io/posts/shader-permutations-part1/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>The Shader Permutation Problem - Part 1: How Did We Get Here?</span>
			</a>
			<a class="prev-post" href="https://therealmjp.github.io/posts/rtg2-bindless/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Read My Chapter in Ray Tracing Gems II!</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://utteranc.es/client.js"
        repo="TheRealMJP/TheRealMJP.github.io"
        issue-term="title"
        label="comments"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://therealmjp.github.io/">MJP</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://therealmjp.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://therealmjp.github.io/js/main.min.d1b247cbe4b98a4f2db4cae020d2b180d0b585a34ed4d751cb0072d5676fc52a.js" integrity="sha256-0bJHy+S5ik8ttMrgINKxgNC1haNO1NdRywBy1WdvxSo="></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>



</body>

</html>
