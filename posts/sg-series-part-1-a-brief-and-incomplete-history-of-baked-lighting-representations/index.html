<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations">
<meta itemprop="description" content="This is part 1 of a series on Spherical Gaussians and their applications for pre-computed lighting. You can find the other articles here:
Part 1 - A Brief (and Incomplete) History of Baked Lighting Representations
Part 2 - Spherical Gaussians 101
Part 3 - Diffuse Lighting From an SG Light Source
Part 4 - Specular Lighting From an SG Light Source
Part 5 - Approximating Radiance and Irradiance With SG&rsquo;s">


<meta itemprop="datePublished" content="2016-10-10T07:05:49&#43;00:00" />
<meta itemprop="dateModified" content="2016-10-10T07:05:49&#43;00:00" />
<meta itemprop="wordCount" content="4088">



<meta itemprop="keywords" content="Graphics," />
<meta property="og:title" content="SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations" />
<meta property="og:description" content="This is part 1 of a series on Spherical Gaussians and their applications for pre-computed lighting. You can find the other articles here:
Part 1 - A Brief (and Incomplete) History of Baked Lighting Representations
Part 2 - Spherical Gaussians 101
Part 3 - Diffuse Lighting From an SG Light Source
Part 4 - Specular Lighting From an SG Light Source
Part 5 - Approximating Radiance and Irradiance With SG&rsquo;s" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therealmjp.github.io/posts/sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/" />
<meta property="article:published_time" content="2016-10-10T07:05:49+00:00" />
<meta property="article:modified_time" content="2016-10-10T07:05:49+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations"/>
<meta name="twitter:description" content="This is part 1 of a series on Spherical Gaussians and their applications for pre-computed lighting. You can find the other articles here:
Part 1 - A Brief (and Incomplete) History of Baked Lighting Representations
Part 2 - Spherical Gaussians 101
Part 3 - Diffuse Lighting From an SG Light Source
Part 4 - Specular Lighting From an SG Light Source
Part 5 - Approximating Radiance and Irradiance With SG&rsquo;s"/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations</title>
	<link rel="stylesheet" href="https://therealmjp.github.io/css/style.min.568c54a56780af2a70c45272522247710b69dbfc080b315211fb98381e3796f8.css" integrity="sha256-VoxUpWeArypwxFJyUiJHcQtp2/wICzFSEfuYOB43lvg=">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://therealmjp.github.io/">The Danger Zone</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://therealmjp.github.io/posts/">Posts</a>
				<a href="https://therealmjp.github.io/about/">About</a>
				<a href="https://therealmjp.github.io/publications/">Publications</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/TheRealMJP" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/mynameismjp" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="mailto:mpettineo@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://therealmjp.github.io/posts/">Posts</a></li>
			<li><a href="https://therealmjp.github.io/about/">About</a></li>
			<li><a href="https://therealmjp.github.io/publications/">Publications</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Oct 10, 2016</span></div>
				<h1>SG Series Part 1: A Brief (and Incomplete) History of Baked Lighting Representations</h1>
			</header>
			<div class="content">
				

<p><em>This is part 1 of a series on Spherical Gaussians and their applications for pre-computed lighting. You can find the other articles here:</em></p>

<p>Part 1 - <a href="../sg-series-part-1-a-brief-and-incomplete-history-of-baked-lighting-representations/">A Brief (and Incomplete) History of Baked Lighting Representations</a><br>
Part 2 - <a href="../sg-series-part-2-spherical-gaussians-101/">Spherical Gaussians 101</a><br>
Part 3 - <a href="../sg-series-part-3-diffuse-lighting-from-an-sg-light-source/">Diffuse Lighting From an SG Light Source</a><br>
Part 4 - <a href="../sg-series-part-4-specular-lighting-from-an-sg-light-source/">Specular Lighting From an SG Light Source</a><br>
Part 5 - <a href="../sg-series-part-5-approximating-radiance-and-irradiance-with-sgs/">Approximating Radiance and Irradiance With SG&rsquo;s</a><br>
Part 6 - <a href="../sg-series-part-6-step-into-the-baking-lab/">Step Into The Baking Lab</a><br></p>

<p>For part 1 of this series, I&rsquo;m going to provide some background material for our research into Spherical Gaussians. The main purpose is cover some of the alternatives to the approach we used for The Order: 1886, and also to help you understand why we decided to persue Spherical Gaussians. The main empahasis is going to be on discussing what exactly we store in pre-baked lightmaps and probes, and how that data is used to compute diffuse or specular lighting. If you&rsquo;re already familiar with the concepts of pre-computing radiance or irradiance and approximating them using basis functions like the HL2 basis or Spherical Harmonics, then you will probably want to skip to the next article.</p>

<p>Before we get started, here&rsquo;s a quick glossary of the terms I use the formulas:</p>

<ul>
<li>\( L_{o} \) the outgoing radiance (lighting) towards the viewer</li>
<li>\( L_{i} \) the incoming radiance (lighting) hitting the surface</li>
<li>\( \mathbf{o} \) the direction pointing towards the viewer (often denoted as &ldquo;V&rdquo; in shader code dealing with lighting)</li>
<li>\( \mathbf{i} \) the direction pointing towards the incoming radiance hitting the surface (often denoted as &ldquo;L&rdquo; in shader code dealing with lighting)</li>
<li>\( \mathbf{n} \) the direction of the surface normal</li>
<li>\( \mathbf{x} \) the 3D location of the surface point</li>
<li>\( \int_{\Omega} \) integral about the hemisphere</li>
<li>\( \theta_{i} \) the angle between the surface normal and the incoming radiance direction</li>
<li>\( \theta_{o} \) the angle between the surface normal and the outgoing direction towards the viewer</li>
<li>\( f() \) the BRDF of the surface</li>
</ul>

<h2 id="the-olden-days-storing-irradiance">The Olden Days - Storing Irradiance<a href="#the-olden-days-storing-irradiance" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>Games have used pre-computed lightmaps for almost as long as they have been using shaded 3D graphics, and they&rsquo;re still quite popular in 2016. The idea is simple: pre-compute a lighting value for every texel, then sample those lighting values at runtime to determine the final appearance of a surface. It&rsquo;s a simple concept to grasp, but there are some details you might not think about if you&rsquo;re just learning how they work. For instance, what exactly does it mean to store &ldquo;lighting&rdquo; in a texture? What exact value are we computing, anyway? In the early days the value fetched from the lightmap was simply multiplied with the material&rsquo;s diffuse albedo color (typically done with fixed-function texture stages), and then directly output to the screen. Ignoring the issue of gamma correction and sRGB transfer functions for the moment, we can work backwards from this simple description to describe this old-school approach in terms of the rendering equation. This might seem like a bit of a pointless exercise, but I think it helps build a solid base that we can use to discuss more advanced techniques.</p>

<p>So we know that our lightmap contains a single fixed color per-texel, and we apply it the same way regardless of the viewing direction for a given pixel. This implies that we&rsquo;re using a simple Lambertian diffuse BRDF, since it lacks any sort of view-dependence. Recall that we compute the outgoing radiance for a single point using the following integral:</p>

<p>$$ L_{o}(\mathbf{o}, \mathbf{x}) = \int_{\Omega}f(\mathbf{i}, \mathbf{o}, \mathbf{x}) \cdot L_{i}(\mathbf{i}, \mathbf{x}) \cdot cos(\theta_{i}) \cdot d\Omega $$</p>

<p>If we substitute the standard diffuse BRDF of \( \frac{C_{diffuse}}{\pi} \) for our BRDF (where Cdiffuse is the diffuse albedo of the surface), then we get the following:</p>

<p>$$ L_{o}(\mathbf{o}, \mathbf{x}) = \int_{\Omega} \frac{C_{diffuse}}{\pi} \cdot L_{i}(\mathbf{i}, \mathbf{x}) \cdot cos(\theta_{i}) \cdot d\Omega  $$</p>

<p>$$ = \frac{C_{diffuse}}{\pi} \int_{\Omega} L_{i}(\mathbf{i}, \mathbf{x}) \cdot cos(\theta_{i}) \cdot d\Omega $$</p>

<p>On the right side we see that we can pull the constant terms out the integral (the constant term is actually the entire BRDF!), and what we&rsquo;re left with lines up nicely with how we handle lightmaps: the expensive integral part is pre-computed per-texel, and then the constant term is applied at runtime per-pixel. The &ldquo;integral part&rdquo; is actually computing the incident irradiance, which lets us finally identify the quantity being stored in the lightmap: it&rsquo;s irradiance! In practice however most games would not apply the 1 / π term at runtime, since it would have been impractical to do so. Instead, let&rsquo;s assume that the 1 / π was &ldquo;baked&rdquo; into the lightmap, since it&rsquo;s constant for all surfaces (unlike the diffuse albedo, which we consider to be <em>spatially varying</em>). In that case, we&rsquo;re actually storing a reflectance value that takes the BRDF into account. So if we wanted to be precise, we would say that it contains &ldquo;the diffuse reflectance of a surface with Cdiffuse = 1.0&rdquo;, AKA the maximum possible outgoing radiance for a surface with a diffuse BRDF.</p>

<h2 id="light-map-meet-normal-map">Light Map: Meet Normal Map<a href="#light-map-meet-normal-map" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>One of the key concepts of lightmapping is the idea of reconstructing the final surface appearance using data that&rsquo;s stored at different rates in the spatial domain. Or in simpler words, we store lightmaps using one texel density while combining it with albedo maps that have a different (usually higher) density. This lets us retain the appearance of high-frequency details without actually computing irradiance integrals per-pixel. But what if we want to take this concept a step further? What it we also want the irradiance itself to vary in response to texture maps, and not just the diffuse albedo? By the early 2000&rsquo;s normal maps were starting to see common use for this purpose, however they were generally only used when computing the contribution from punctual light sources. Normal maps were no help with light maps that only stored a single (scaled) irradiance value, which meant that that pure ambient lighting would look very flat compared to areas using dynamic lighting:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/flat_lightmaps.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/flat_lightmaps.png?w=1024" alt="Flat_Lightmaps" /></a></p>

<p><center><em>Areas in direct lighting (on the right) have a varying appearance due to a normal map, but areas in shadow (on the left) have no variation due to being lit by a baked lightmap containing only a single irradiance value.</em></center></p>

<p>To make  lightmaps work with normal mapping, we need to stop storing a single value and instead somehow store a <em>distribution</em> of irradiance values for every texel. Normal maps contain a range of normal directions, where those directions are generally restricted to the hemisphere around a point&rsquo;s surface normal. So if we want our lightmap to store irradiance values for all possible normal map values, then it must contain a distribution of irradiance that&rsquo;s defined for that same hemisphere. One of the earliest and simplest examples of such a distribution was used by <a href="http://www.valvesoftware.com/publications/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf">Half-Life 2</a>[1], and was referred to as <a href="http://www2.ati.com/developer/gdc/D3DTutorial10_Half-Life2_Shading.pdf">Radiosity Normal Mapping</a>[2]:</p>

<p><img src="https://mynameismjp.files.wordpress.com/2016/06/hl2_basis.png" alt="HL2_Basis" />
<center><em>Image from &ldquo;Shading in Valve’s Source Engine &ldquo;, SIGGRAPH 2006</em></center></p>

<p>Valve essentially modified their lightmap baker to compute 3 values instead of 1, with each value computed by projecting the irradiance signal onto one of the corresponding orthogonal <a href="https://en.wikipedia.org/wiki/Basis_(linear_algebra)">basis vectors</a> in the above image. At runtime, the irradiance value used for shading would be computed by blending the 3 lightmap values based on the cosine of the angle between the normal map direction and the 3 basis directions (which is cheaply computed using a dot product). This allowed them to effectively vary the irradiance based on the normal map direction, thus avoiding the &ldquo;flat ambient&rdquo; problem described above.</p>

<p>While this worked for their static geometry, there still remained the issue of applying pre-computed lighting to dynamic objects and characters. Some early games (such as the original Quake) used tricks like sampling the lightmap value at a character&rsquo;s feet, and using that value to compute ambient lighting for the entire mesh. Other games didn&rsquo;t even do that much, and would just apply dynamic lights combined with a global ambient term. Valve decided to take a more sophisticated approach that extended their hemispherical lightmap basis into a full spherical basis formed by 6 orthogonal basis vectors:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/10/ambientcube.png"><img src="https://mynameismjp.files.wordpress.com/2016/10/ambientcube.png" alt="ambientcube" /></a>
<center><em>Image from &ldquo;Shading in Valve’s Source Engine &ldquo;, SIGGRAPH 2006</em></center></p>

<p>The basis vectors coincided with the 6 face directions of a unit cube, which led Valve to call this basis the &ldquo;Ambient Cube&rdquo;. By projecting irradiance in all directions around a point in space (instead of a hemisphere surrounding a surface normal) onto their basis functions, a dynamic mesh could sample irradiance for any normal direction and use it to compute diffuse lighting. This type of representation is often referred to as a <em>lighting probe</em>, or often just &ldquo;probe&rdquo; for short.</p>

<h2 id="going-specular">Going Specular<a href="#going-specular" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>With Valve&rsquo;s basis we can combine normal maps and light maps to get diffuse lighting that can vary in response to high-frequency normal maps. So what&rsquo;s next? For added realism we would ideally like to support more complex BRDF&rsquo;s, including view-dependent specular BRDF&rsquo;s. Half-Life 2 handled environment specular by pre-generating cubemaps at hand-placed probe locations, which is still a common approach used by modern games (albeit with the addition of <a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">pre-filtering</a>[3] used to approximate the response from a microfacet BRDF). However the large memory footprint of cubemaps limits the practical density of specular probes, which can naturally lead to issues caused by incorrect parallax or disocclusion.</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/envmap_disocclusion.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/envmap_disocclusion.png?w=756" alt="EnvMap_Disocclusion" /></a>
<center><em>A combination of incorrect parallax and disocclusion when using a pre-filtered environment as a source for environment specular. Notice the bright edges on the sphere, which are actually caused by the sphere reflecting itself!</em></center></p>

<p>With that in mind it would nice to be able to get some sort of specular response out of our lightmaps, even if only for a subset of materials. But if that is our goal, then our approach of storing an irradiance distribution starts to become a hinderance. Recall from earlier that with a diffuse BRDF we were able to completely pull the BRDF out of the irradiance integral, since the Lambertian diffuse BRDF is just a constant term. This is no longer the case even with a simple specular BRDF, whose value varies depending on both the viewing direction as well as the incident lighting direction.</p>

<p>If you&rsquo;re working with the Half-Life 2 basis (or something similar), a tempting option might be to compute a specular term as if the 3 basis directions were directional lights. If you think about what this means, it&rsquo;s basically what you get if you decide to say &ldquo;screw it&rdquo; and pull the specular BRDF out of the irradiance integral. So instead of Integrate(BRDF * Lighting * cos(theta)), you&rsquo;re doing BRDF * Integrate(Lighting * cos(theta)). This will definitely give you <em>something,</em> and it&rsquo;s perhaps a lot better than nothing. But you&rsquo;ll also effectively lose out on a ton of your specular response, since you&rsquo;ll only get specular when your viewing direction appropriately lines up with your basis directions according the the BRDF slice. To show you what I mean by this, here&rsquo;s a comparison:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/09/irradiance_specular_comparison1.png"><img src="https://mynameismjp.files.wordpress.com/2016/09/irradiance_specular_comparison1.png?w=542" alt="irradiance_specular_comparison" /></a>
<center><em>The top image shows a path-traced rendering of a green wall being lit by direct sun lighting. The middle image shows the indirect specular component of the top image, with exposure increased by 4x. The bottom image shows the resulting specular from treating the HL2 basis directions as directional lights.</em></center></p>

<p>Hopefully these images clearly show the problem that I&rsquo;m describing. In the bottom image, you get specular reflections that look just like they came from a few point lights, since that&rsquo;s effectively what you&rsquo;re simulating. Meanwhile in the middle image with proper environment reflections, you can see that the the entire green wall effectively acts as an area light, and you get a very broad specular reflections across the entire floor. In general the problem tends to be less noticeable though as roughness increases, since higher roughness naturally results in broader, less-defined reflections that are harder to notice.</p>

<h2 id="let-s-try-spherical-harmonics">Let&rsquo;s Try Spherical Harmonics<a href="#let-s-try-spherical-harmonics" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>If we want to do better, we must instead find a way to store a radiance distribution and then efficiently integrate it against our BRDF. It&rsquo;s at this point that we turn to spherical harmonics. Spherical harmonics (SH for short) have become a popular tool for real-time graphics, typically as a way to store an approximation of indirect lighting at discrete probe locations. I&rsquo;m not going to go into the full specifics of SH since that could easily fill an <a href="http://www.research.scea.com/gdc2003/spherical-harmonic-lighting.pdf">entire article</a>[4] on its own. If you have no experience with SH, the key thing to know about them is that they basically let you approximate a function defined on a sphere using a handful of coefficients (typically either 4 or 9 floats per RGB channel). It&rsquo;s sort-of as if you had a compact cubemap, where you can take a direction vector and get back a value associated with that direction. The big catch is that you can only represent very low-frequency (fuzzy) signals with lower-order SH, which can limit what sort of things you can do with it. You can project detailed, high-frequency signals onto SH if you want to, but the resulting projection will be very blurry. Here&rsquo;s an example showing what an HDR environment map looks like projected onto L2 SH, which requires 27 coefficients for RGB:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/wells_radiance.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/wells_radiance.png" alt="Wells_Radiance" /></a></p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/wells_radiance_sh.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/wells_radiance_sh.png" alt="Wells_Radiance_SH" /></a></p>

<p><center><em>The top image is an HDR environment map containing incoming radiance values about a sphere, while the bottom image shows the result of projecting that environment onto L2 spherical harmonics.</em></center></p>

<p>In the case of irradiance, SH can work pretty well since it&rsquo;s naturally low-frequency. The integration of incoming radiance against the cosine term effectively acts as a low-pass filter, which makes it a suitable candidate for approximation with SH. So if we project irradiance onto SH for every probe location or lightmap texel, we can now do an SH &ldquo;lookup&rdquo; (which is basically a few computations followed by a dot product with the coefficients) to get the irradiance in any direction on the sphere. This means we can get spatial variation from albedo and normal maps just like with the HL2 basis!</p>

<p>It also turns out that SH is pretty useful for <em>computing</em> irradiance from input radiance, since we can do it really cheaply. In fact it can do it so cheaply, it can be done at runtime by folding it into the SH lookup process. The reason it&rsquo;s so cheap is because SH is effectively a frequency-domain representation of the signal, and when you&rsquo;re in the frequency domain convolutions can be done with simple multiplication. In the spatial domain, convolution with a cubemap is an N^2 operation involving many samples from an input radiance cubemap. If you&rsquo;re interested in the full details, the process was described in Ravi Ramamoorthi&rsquo;s <a href="https://cseweb.ucsd.edu/~ravir/papers/envmap/">seminal paper</a>[5] from 2001, with derivations provided in <a href="https://cseweb.ucsd.edu/~ravir/papers/invlamb/">another article</a>[6].</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/sh_diffuse.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/sh_diffuse.png?w=300" alt="SH_Diffuse" /></a></p>

<p><center><em>The Stanford Bunny model being lit with diffuse lighting from an L2 spherical harmonics probe</em></center></p>

<p>So we&rsquo;ve established that SH works for approximating irradiance, and that we can convert from radiance to irradiance at runtime. But what does this have to do with specular? By storing an approximation of radiance instead of irradiance in our probes or lightmaps (albeit, a very blurry version of radiance), we now have the signal that we need to integrate our specular BRDF against in order to produce specular reflections. All we need is an SH representation of our BRDF, and we&rsquo;re a dot product away from environment specular! The only problem we have to solve is how to actually <em>get</em> an SH representation of our BRDF.</p>

<p>Unfortunately a microfacet specular BRDF  is quite a bit more complicated than a Lambertian diffuse BRDF, which makes our lives more difficult. For diffuse lighting we only needed to worry about the cosine lobe, which has the same shape regardless of the material or viewing direction. However a specular lobe will vary in shape and intensity depending on the viewing direction, material roughness, and the fresnel term at zero incidence (AKA F0). If all else fails, we can always use monte-carlo techniques to pre-compute the coefficients and store the result in a lookup texture. At first it may seem like we need at parameterize our lookup table on 4 terms, since the viewing direction is two-dimensional. However we can drop a dimension if we follow in the <a href="https://developer.amd.com/wordpress/media/2012/10/S2008-Chen-Lighting_and_Material_of_Halo3.pdf">footsteps</a>[7] of the intrepid engineers at Bungie, who used a neat trick for their <a href="http://developer.amd.com/wordpress/media/2013/01/Chapter01-Chen-Lighting_and_Material_of_Halo3.pdf">SH specular implementation in Halo 3</a>[8]. The key insight that they shared was that the specular lobe shape doesn&rsquo;t actually change as the viewer rotates around the local Z axis of the shading point (AKA the surface normal). It actually only changes based on the <em>viewing angle</em>, which is the angle between the view vector and the local Z axis of the surface. If we exploit this knowledge, we can pre-compute the coefficients for the set of possible viewing directions that are aligned with the local X axis. Then at runtime, we can rotate the coefficients so that the resulting lobe lines up with the actual viewing direction. Here&rsquo;s an image to show you what I mean:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/06/sh_rotation.png"><img src="https://mynameismjp.files.wordpress.com/2016/06/sh_rotation.png?w=296" alt="SH_Rotation" /></a></p>

<p><center><em>Rotating a specular lobe from the X axis to its actual location based on the viewing direction, which is helpful for pre-computing the SH coefficients into a lookup texture</em></center></p>

<p>So in this image the checkerboard is the surface being shaded, and the red, green and blue arrows are the local X, Y, and Z axes of the surface. The transparent lobe represents the specular lobe that we precomputed for a viewpoint that&rsquo;s aligned with the X axis, but has the same viewing angle. The blue arrow shows how we can rotate the specular lobe from its original position to the actual position of the lobe based on the current viewing position, giving us the desired specular response. Here&rsquo;s a comparison showing what it looks like it in action:</p>

<p><a href="https://mynameismjp.files.wordpress.com/2016/09/sh_specular_comparison.png"><img src="https://mynameismjp.files.wordpress.com/2016/09/sh_specular_comparison.png?w=481" alt="sh_specular_comparison" /></a></p>

<p><center><em>The top image is a scene rendered with a path tracer. The middle image shows the indirect specular as rendered by a path tracer, with exposure increased 4x. The bottom image shows the indirect specular term computing an L2 SH lightmap, also with exposure increased by 4x.</em></center></p>

<p>Not too bad, eh? Or at least&hellip;not too bad as long as we&rsquo;re willing to store 27 coefficients per lightmap texel, and we&rsquo;re only concerned with rough materials. The comparison image used a GGX α parameter of 0.39, which is fairly rough.</p>

<p>One common issue with issue with SH is a phenomenon known as &ldquo;ringing&rdquo;, which is described in Peter-Pike Sloan&rsquo;s <a href="http://www.ppsloan.org/publications/StupidSH36.pdf">Stupid Spherical Harmonics Tricks</a>[9]. Ringing artifacts tends to show up when you have a very intense light source one side of the sphere. When this happens, the SH projection will naturally result in negative lobes on the opposite side of the sphere, whi<br>
h an result very low (or even negative!) values when evaluated. It&rsquo;s generally not too much of an issue for 2D lightmaps, since lightmaps are only concerned with the incoming radiance for a hemisphere surrounding the surface normal. However they often show up in probes, which store radiance or irradiance about the entire sphere. The solution suggested by Peter-Pike Sloan is to apply a windowing function to the SH coefficients, which will filter out the ringing artifacts. However the windowing will also introduce additional blurring, which may remove high-frequency components from the original signal being projected. The following image shows how ringing artifacts manifest when using SH to compute irradiance from an environment with a bright area light, and also shows how windowing affects the final result:</p>

<p><img src="https://mynameismjp.files.wordpress.com/2016/09/sh_ringing_comparison.png" alt="sh_ringing_comparison" /></p>

<p><center><em>A sphere with a Lambertian diffuse BRDF being lit by a lighting environment with a strong area light source. The left image shows the ground-truth result of using monte-carlo integration. The middle image shows the result of projecting radiance onto L2 SH, and then computing irradiance. The right image shows the result of applying a windowing function to the L2 SH coefficients before computing irradiance.</em></center></p>

<p>Update 8/6/2019: For L1 (2-band SH), Graham Hazel developed a <a href="https://grahamhazel.com/blog/2017/12/22/converting-sh-radiance-to-irradiance/">technique</a> for Geomerics that reconstructions irradiance from radiance with less ringing and better contrast compared with the process originally developed by Ravi Ramamoorthi. The slides from his presentation have disappeared from the Geomerics website, but you can find the archived version <a href="https://web.archive.org/web/20160313132301/http://www.geomerics.com/wp-content/uploads/2015/08/CEDEC_Geomerics_ReconstructingDiffuseLighting1.pdf">here</a>. You can also find a reference implementation in Yuriy O&rsquo;Donnell&rsquo;s <a href="https://github.com/kayru/Probulator/blob/master/Source/Probulator/SphericalHarmonics.h#L136">Probulator code</a>.</p>

<h2 id="references">References<a href="#references" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>[1] <a href="http://www.valvesoftware.com/publications/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf">Shading in Valve&rsquo;s Source Engine (SIGGRAPH 2006)</a><br>
[2] <a href="http://www2.ati.com/developer/gdc/D3DTutorial10_Half-Life2_Shading.pdf">Half Life 2 / Valve Source Shading</a><br>
[3] <a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">Real Shading in Unreal Engine 4</a><br>
[4] <a href="https://basesandframes.files.wordpress.com/2016/05/spherical_harmonic_lighting_gritty_details_green_2003.pdf">Spherical Harmonic Lighting: The Gritty Details</a><br>
[5] <a href="https://cseweb.ucsd.edu/~ravir/papers/envmap/">An Efficient Representation for Irradiance Environment Maps</a><br>
[6] <a href="https://cseweb.ucsd.edu/~ravir/papers/invlamb/">On the Relationship between Radiance and Irradiance: Determining the illumination from images of a convex Lambertian object</a><br>
[7] <a href="https://developer.amd.com/wordpress/media/2012/10/S2008-Chen-Lighting_and_Material_of_Halo3.pdf">The Lighting and Material of Halo 3 (Slides)</a><br>
[8] <a href="http://developer.amd.com/wordpress/media/2013/01/Chapter01-Chen-Lighting_and_Material_of_Halo3.pdf">The Lighting and Material of Halo 3 (Course Notes)</a><br>
[9] <a href="http://www.ppsloan.org/publications/StupidSH36.pdf">Stupid Spherical Harmonics Tricks</a></p>

<hr />

<h2 id="comments">Comments:<a href="#comments" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>

<p>###
[fang]( &ldquo;fangsunjian2@gmail.com&rdquo;) - <time datetime="2017-02-06 01:38:22">Feb 1, 2017</time></p>

<p>Hello! Thank you for sharing such great article. I have a question here. How do you think about vertex baking and texel baking? Why nowadays people tend to use texel baking instead of vertex baking?
<hr />
###
<a href="http://mynameismjp.wordpress.com/" title="mpettineo@gmail.com">MJP</a> - <time datetime="2016-11-01 12:58:58">Nov 2, 2016</time></p>

<p>Hey Tyler, for the bunny image I used the &ldquo;wells&rdquo; environment in probulator, which doesn&rsquo;t have as high of a dynamic range as the &ldquo;ennis&rdquo; probe. With the &ldquo;wells&rdquo; probe the ringing isn&rsquo;t particularly noticeable, so I used the standard L2 SH approach with no windowing.
<hr />
###
<a href="http://mynameismjp.wordpress.com/" title="mpettineo@gmail.com">MJP</a> - <time datetime="2017-02-14 01:16:27">Feb 2, 2017</time></p>

<p>There are pros and cons to either approach. Vertex baking tends to be easier to start with since you already have the structure set up for you, and there&rsquo;s no need to generate a unique 2D parameterization of your entire scene. However the major downside is that your sample density is effectively tied to your vertex density and topology. This means that meshes may need to be tessellated in order to capture high-frequency lighting changes, which can increase vertex, geometry, and pixel costs. With lightmaps the texel density can be adjusted independently of the underlying geometry, which makes it much easier spot fix problem areas. In our studio this was actually very important, since it removed a dependency between the lighting artists and environment artists. The structured 2D layout of textures also tends to be much better for interpolation and compression. On recent hardware you can use block compression formats like BC6H to drastically reduce the memory footprint, which is of course a huge win if you&rsquo;re memory constrained. Personally I keep a close eye on papers that presentations that look into alternative forms of storing baked sample points for a scene. For instance there are some presentations that have discussed using a sparse 3D grid to store data without needing vertices or 2D maps, and others that have used basis functions to &ldquo;splat&rdquo; the contribution of arbitrary points onto a scene.
<hr />
###
<a href="http://twitter.com/notCamelCase" title="notCamelCase@twitter.example.com">Tayfun K. (@notCamelCase)</a> - <time datetime="2016-10-10 02:04:23">Oct 1, 2016</time></p>

<p>Very informative posts, thank you! Shouldn&rsquo;t this be the &lsquo;middle image&rsquo; below in comparison of indirect speculars? &ldquo;Meanwhile in the bottom image with proper environment reflections, you can see that the the entire green wall effectively acts as an area light &hellip;&rdquo;
<hr />
###
[Tyler]( &ldquo;tylerrobertsondeveloper@gmail.com&rdquo;) - <time datetime="2016-11-01 10:01:22">Nov 2, 2016</time></p>

<p>It&rdquo;s difficult to tell, is the source IBL bright enough for the ringing artifact visible on the test with the bunny? Or did you use the windowed L2 SH there?
<hr />
###
<a href="http://mynameismjp.wordpress.com/" title="mpettineo@gmail.com">MJP</a> - <time datetime="2016-10-10 17:12:18">Oct 1, 2016</time></p>

<p>Indeed, that&rsquo;s exactly right: your normal maps are typically going to be much higher density than your light maps, since normal maps can be tiled and light maps will be completely unique over all surfaces (plus the lightmaps may have a larger per-texel footprint if they are HDR). So technically you *could* sample the normal maps when baking the lightmap, but since the texel density is much lower it would be as if you used a blurrier, downscaled version of the normal map.
<hr />
###
[atrix256]( &ldquo;alan.wolfe@gmail.com&rdquo;) - <time datetime="2016-10-10 14:31:41">Oct 1, 2016</time></p>

<p>Apologies, I get it now. The normals can&rsquo;t be taken into consideration because the light map is much lower resolution than the details needed to support features at the normal map level. Thanks for writing these, they are a great read (:
<hr />
###
[atrix256]( &ldquo;alan.wolfe@gmail.com&rdquo;) - <time datetime="2016-10-10 09:54:10">Oct 1, 2016</time></p>

<p>Hello! For the case of ambient lighting looking flat even in presence of a normal map, near the top of the article, why wasn&rsquo;t the normal map considered when calculating the baked lighting? It seems like that would also solve the problem, unless there is some reason that is undesirable?
<hr />
###
<a href="http://mynameismjp.wordpress.com/" title="mpettineo@gmail.com">MJP</a> - <time datetime="2016-10-10 09:50:45">Oct 1, 2016</time></p>

<p>Yes you&rsquo;re 100% correct: that sentence is referring to the middle image, not the bottom image. It&rsquo;s now been corrected. Thank you for pointing out the mistake!
<hr /></p>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://therealmjp.github.io/tags/graphics">Graphics</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>4088 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2016-10-10 00:05 -0700</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://therealmjp.github.io/posts/sg-series-part-2-spherical-gaussians-101/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>SG Series Part 2: Spherical Gaussians 101</span>
			</a>
			<a class="prev-post" href="https://therealmjp.github.io/posts/new-blog-series-lightmap-baking-and-spherical-gaussians/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>New Blog Series: Lightmap Baking and Spherical Gaussians</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://utteranc.es/client.js"
        repo="TheRealMJP/TheRealMJP.github.io"
        issue-term="title"
        label="comments"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://therealmjp.github.io/">MJP</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://therealmjp.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://therealmjp.github.io/js/main.min.35ccbf1cdceb91e4c64c06b5d009d6e2977fafe56beda7762febd4e67528d2ac.js" integrity="sha256-Ncy/HNzrkeTGTAa10AnW4pd/r+Vr7ad2L+vU5nUo0qw="></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>



</body>

</html>
