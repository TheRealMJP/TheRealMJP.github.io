<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="Shader Printf in HLSL and DX12">
<meta itemprop="description" content="Overall Approach Setting Up The Print Buffer The &ldquo;Magic&rdquo; Debug Info Buffer Dealing With The String Problem A Cursed Path Packing It All Into A Buffer Reading Back On The CPU Going Beyond Printf CR LF Unless you&rsquo;re fortunate enough to to be working exclusively in Cuda, debugging GPU shaders is still very much &ldquo;not great&rdquo; in the year 2024. Tools like RenderDoc and PIX are amazing and do provide the ability to step through a shader and inspect variables, but they&rsquo;re fundamentally tied to a &ldquo;capture&rdquo; workflow."><meta itemprop="datePublished" content="2024-01-07T00:00:00+00:00" />
<meta itemprop="dateModified" content="2024-01-07T00:00:00+00:00" />
<meta itemprop="wordCount" content="3763"><meta itemprop="image" content="https://therealmjp.github.io/images/shader-printf.png">
<meta itemprop="keywords" content="Graphics,DX12," /><meta property="og:title" content="Shader Printf in HLSL and DX12" />
<meta property="og:description" content="Overall Approach Setting Up The Print Buffer The &ldquo;Magic&rdquo; Debug Info Buffer Dealing With The String Problem A Cursed Path Packing It All Into A Buffer Reading Back On The CPU Going Beyond Printf CR LF Unless you&rsquo;re fortunate enough to to be working exclusively in Cuda, debugging GPU shaders is still very much &ldquo;not great&rdquo; in the year 2024. Tools like RenderDoc and PIX are amazing and do provide the ability to step through a shader and inspect variables, but they&rsquo;re fundamentally tied to a &ldquo;capture&rdquo; workflow." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therealmjp.github.io/posts/hlsl-printf/" /><meta property="og:image" content="https://therealmjp.github.io/images/shader-printf.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-01-07T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://therealmjp.github.io/images/shader-printf.png"/>

<meta name="twitter:title" content="Shader Printf in HLSL and DX12"/>
<meta name="twitter:description" content="Overall Approach Setting Up The Print Buffer The &ldquo;Magic&rdquo; Debug Info Buffer Dealing With The String Problem A Cursed Path Packing It All Into A Buffer Reading Back On The CPU Going Beyond Printf CR LF Unless you&rsquo;re fortunate enough to to be working exclusively in Cuda, debugging GPU shaders is still very much &ldquo;not great&rdquo; in the year 2024. Tools like RenderDoc and PIX are amazing and do provide the ability to step through a shader and inspect variables, but they&rsquo;re fundamentally tied to a &ldquo;capture&rdquo; workflow."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Shader Printf in HLSL and DX12</title>
	<link rel="stylesheet" href="https://therealmjp.github.io/css/style.min.4bc523c643bd50ebce05154df32e255bc3b0c9bae8e5b0be991a7f5163fae5af.css" integrity="sha256-S8UjxkO9UOvOBRVN8y4lW8Owybro5bC+mRp/UWP65a8=">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://therealmjp.github.io/">The Danger Zone</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://therealmjp.github.io/posts/">Posts</a>
				<a href="https://therealmjp.github.io/about/">About</a>
				<a href="https://therealmjp.github.io/publications/">Publications</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<button id="img-btn" class="hdr-btn" title="Featured Image"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></button><span class="hdr-social hide-in-mobile"><a href="https://github.com/TheRealMJP" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://bsky.app/profile/mjp123.bsky.social" target="_blank" rel="noopener me" title="Bluesky"><svg width="24" height="24" viewBox="0 0 600 600" preserveAspectRatio="xMinYMin meet" version="1.1" xmlns="http://www.w3.org/2000/svg" class="feather">
 <path d="m135.72 44.03c66.496 49.921 138.02 151.14 164.28 205.46 26.262-54.316 97.782-155.54 164.28-205.46 47.98-36.021 125.72-63.892 125.72 24.795 0 17.712-10.155 148.79-16.111 170.07-20.703 73.984-96.144 92.854-163.25 81.433 117.3 19.964 147.14 86.092 82.697 152.22-122.39 125.59-175.91-31.511-189.63-71.766-2.514-7.3797-3.6904-10.832-3.7077-7.8964-0.0174-2.9357-1.1937 0.51669-3.7077 7.8964-13.714 40.255-67.233 197.36-189.63 71.766-64.444-66.128-34.605-132.26 82.697-152.22-67.108 11.421-142.55-7.4491-163.25-81.433-5.9562-21.282-16.111-152.36-16.111-170.07 0-88.687 77.742-60.816 125.72-24.795z" style="font-variation-settings:normal" stroke="currentColor" stroke-linejoin="bevel" paint-order="stroke fill markers" fill="#1185fe"/>
</svg></a><a href="mailto:mpettineo@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://therealmjp.github.io/posts/">Posts</a></li>
			<li><a href="https://therealmjp.github.io/about/">About</a></li>
			<li><a href="https://therealmjp.github.io/publications/">Publications</a></li>
		</ul>
	</div>




	<div class="bg-img"></div>
	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Jan 7, 2024</span></div>
				<h1>Shader Printf in HLSL and DX12</h1>
			</header>
			<div class="content">
				<p><img src="/images/shader-printf.png" alt=""></p>
<div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#overall-approach">Overall Approach</a></li>
    <li><a href="#setting-up-the-print-buffer">Setting Up The Print Buffer</a></li>
    <li><a href="#the-magic-debug-info-buffer">The &ldquo;Magic&rdquo; Debug Info Buffer</a></li>
    <li><a href="#dealing-with-the-string-problem">Dealing With The String Problem</a>
      <ul>
        <li><a href="#a-cursed-path">A Cursed Path</a></li>
      </ul>
    </li>
    <li><a href="#packing-it-all-into-a-buffer">Packing It All Into A Buffer</a></li>
    <li><a href="#reading-back-on-the-cpu">Reading Back On The CPU</a></li>
    <li><a href="#going-beyond-printf">Going Beyond Printf</a></li>
    <li><a href="#cr-lf">CR LF</a></li>
  </ul>
</nav>
</div>
<p>Unless you&rsquo;re fortunate enough to to be working exclusively in Cuda, debugging GPU shaders is still very much &ldquo;not great&rdquo; in the year 2024. Tools like <a href="https://renderdoc.org/">RenderDoc</a> and <a href="https://devblogs.microsoft.com/pix/introduction/">PIX</a> are amazing and do provide the ability to step through a shader and inspect variables, but they&rsquo;re fundamentally tied to a &ldquo;capture&rdquo; workflow. This means that you need to run your game or app from RenderDoc/PIX in capture mode (which adds overhead), and then capture at least a single frame. Then after the capture is finished you can analyze it, find your draw or dispatch, and finally select which thread you&rsquo;d like to debug. Once you&rsquo;re debugging things generally work, but it&rsquo;s still possible you&rsquo;ll encounter issues due to the way that debugging works in these tools. They are are not simply inspecting the state of an executing (suspended) thread like you would expect from a CPU debugger, instead they work by either emulating shader instructions on the CPU or by patching the shader bytecode to emit intermediate program state to a buffer that can be read by the CPU. Don&rsquo;t get me wrong, these tools are great to have and it&rsquo;s fantastic that they can be used to debug shaders at all. But it&rsquo;s still not enough, and generally more debugging tools are needed for unusually tough problems. Even if vendor-agnostic GPU debuggers were as good as they are on CPU, you would still probably want to reach for some other tools depending on the situation.</p>
<p>In CPU land, the venerable <code>printf</code> and all of its related functions are commonly used for debugging and diagnostics. However we have not yet had a cross-vendor/cross-API way to do the same for shaders. To be fair it&rsquo;s a lot more complicated on a GPU! Shaders run in batches of thousands or even millions of threads, and run on a completely separate processor than what the OS and all of its facilities run on. Despite those issues, Vulkan/SPIR-V <a href="https://www.lunarg.com/wp-content/uploads/2021/08/Using-Debug-Printf-02August2021.pdf">does actually provide a printf</a> that&rsquo;s available from both GLSL and HLSL<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. It comes with caveats though. In particular it&rsquo;s setup so that the messages can be intercepted by a validation layer or by RenderDoc, which makes it more difficult for the engine/app itself to obtain the messages and process them. And of course this doesn&rsquo;t help if you&rsquo;re target D3D12 or other APIs and you&rsquo;d like your prints to work on those platforms as well.</p>
<p>In this article I&rsquo;ll walk through how to build your own shader printf completely in software, using HLSL and D3D12 as the target language and API. The concepts here can be adapted to any API and shader language, although the shading language and compile can (significantly) impact how you handle strings in your shaders,</p>
<h2 id="overall-approach">Overall Approach<a href="#overall-approach" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The printf implementation I&rsquo;m going to describe is going to work like this:</p>
<ul>
<li>Every frame, have the GPU clear a big buffer that we&rsquo;ll use to store the print strings and arguments</li>
<li>Make a debug info buffer SRV available at a &ldquo;magic&rdquo; known descriptor index, which effectively makes it globally available to all shaders through a <code>#include</code>
<ul>
<li>This buffer will have a descriptor index for the print buffer, along with some additional info useful for debugging</li>
</ul>
</li>
<li>When a shader wants to print, it will use an atomic to allocate some space in the big print buffer and stuff the string + data into it</li>
<li>After recording every frame, copy the print buffer to a CPU-accessible readback buffer so that the data can be read back. Then every print can be decoded from the buffer and logged somewhere.</li>
</ul>
<p>Pretty simple in concept! But as always the devil is in the details. Lets go though them one by one.</p>
<h2 id="setting-up-the-print-buffer">Setting Up The Print Buffer<a href="#setting-up-the-print-buffer" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>For our print buffer we don&rsquo;t need anything fancy at all, just a &ldquo;big enough&rdquo; buffer that&rsquo;s writable by the GPU. In my sample framework I do it like this, and also create a pair of matching readback buffers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">PrintBuffer</span><span class="p">.</span><span class="n">Initialize</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">NumElements</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>  <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">CreateUAV</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Name</span> <span class="o">=</span> <span class="sa">L</span><span class="s">&#34;Shader Debug Print Buffer&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">ReadbackBuffer</span><span class="o">&amp;</span> <span class="nl">buffer</span> <span class="p">:</span> <span class="n">PrintReadbackBuffers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="p">.</span><span class="n">InternalBuffer</span><span class="p">.</span><span class="n">Size</span><span class="p">);</span>
</span></span></code></pre></div><p><code>PrintBuffer</code> in this case is a <code>RawBuffer</code> which ends up being a <code>RWByteAddressBuffer</code> in the shader. Every frame it gets cleared to all 0&rsquo;s, which I do with a utility function that just uses a compute shader to do the clear (since <code>ClearUnorderedAccessViewUINT</code> is painful to use in D3D12):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">DX12</span><span class="o">::</span><span class="n">ClearRawBuffer</span><span class="p">(</span><span class="n">cmdList</span><span class="p">,</span> <span class="n">PrintBuffer</span><span class="p">,</span> <span class="n">Uint4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">DX12</span><span class="o">::</span><span class="n">Barrier</span><span class="p">(</span><span class="n">cmdList</span><span class="p">,</span> <span class="n">PrintBuffer</span><span class="p">.</span><span class="n">InternalBuffer</span><span class="p">.</span><span class="n">WriteToWriteBarrier</span><span class="p">());</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">ClearRawBuffer</span><span class="p">(</span><span class="n">ID3D12GraphicsCommandList</span><span class="o">*</span> <span class="n">cmdList</span><span class="p">,</span> <span class="k">const</span> <span class="n">RawBuffer</span><span class="o">&amp;</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">const</span> <span class="n">Uint4</span><span class="o">&amp;</span> <span class="n">clearValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmdList</span><span class="o">-&gt;</span><span class="n">SetComputeRootSignature</span><span class="p">(</span><span class="n">UniversalRootSignature</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmdList</span><span class="o">-&gt;</span><span class="n">SetPipelineState</span><span class="p">(</span><span class="n">clearRawBufferPSO</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">Assert_</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">UAV</span> <span class="o">!=</span> <span class="n">uint32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ClearRawBufferConstants</span> <span class="n">cbData</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">ClearValue</span> <span class="o">=</span> <span class="n">clearValue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">DescriptorIdx</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">UAV</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">Num16ByteElements</span> <span class="o">=</span> <span class="n">uint32</span><span class="p">(</span><span class="n">AlignTo</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">NumElements</span> <span class="o">*</span> <span class="n">buffer</span><span class="p">.</span><span class="n">Stride</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">BindTempConstantBuffer</span><span class="p">(</span><span class="n">cmdList</span><span class="p">,</span> <span class="n">cbData</span><span class="p">,</span> <span class="n">URS_ConstantBuffers</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CmdListMode</span><span class="o">::</span><span class="n">Compute</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">dispatchX</span> <span class="o">=</span> <span class="n">DispatchSize</span><span class="p">(</span><span class="n">cbData</span><span class="p">.</span><span class="n">Num16ByteElements</span><span class="p">,</span> <span class="n">clearRawBufferTGSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmdList</span><span class="o">-&gt;</span><span class="n">Dispatch</span><span class="p">(</span><span class="n">dispatchX</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>That&rsquo;s it for the print buffer setup! Next we&rsquo;ll look at our &ldquo;magic&rdquo; debug info buffer.</p>
<h2 id="the-magic-debug-info-buffer">The &ldquo;Magic&rdquo; Debug Info Buffer<a href="#the-magic-debug-info-buffer" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>In my sample framework I use shader hot-reloading quite frequently, since it provides a super-quick iteration loop that doesn&rsquo;t require re-starting the app. Often one of the reasons for hot-reloading a shader is to add some temporary debugging code in order to figure out why something isn&rsquo;t working correctly. To that end, I wanted to have the ability to add debug prints to any shader without having to change the bindings and re-compile the C++ code. This could potentially be done by either always adding an extra descriptor index to binding structs or by ensuring it was always bound to the root signature, but instead I opted to lean on <a href="https://devblogs.microsoft.com/directx/hlsl-shader-model-6-6/">Shader Model 6.6 bindless</a> by just placing a buffer SRV descriptor at a &ldquo;known&rdquo; static index shared between C++ and GPU code. That makes the buffer available to anyone regardless of what root signature they use or what else is going on in the shader, which is nice. On the C++ side it&rsquo;s simple: I just added a way to allocate a specific descriptor index from my <code>DescriptorHeap</code> type, create an SRV in that descriptor slot, and free the original SRV descriptor:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">Initialize</span><span class="p">({</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">NumElements</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DebugInfo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Dynamic</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">CPUAccessible</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">Name</span> <span class="o">=</span> <span class="sa">L</span><span class="s">&#34;Debug Info Buffer&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="n">PersistentDescriptorAlloc</span> <span class="n">alloc</span> <span class="o">=</span> <span class="n">DX12</span><span class="o">::</span><span class="n">SRVDescriptorHeap</span><span class="p">.</span><span class="n">AllocatePersistent</span><span class="p">(</span><span class="n">MagicDebugBufferIndex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">DX12</span><span class="o">::</span><span class="n">SRVDescriptorHeap</span><span class="p">.</span><span class="n">FreePersistent</span><span class="p">(</span><span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">SRV</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">SRV</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">Index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">uint32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ArraySize_</span><span class="p">(</span><span class="n">alloc</span><span class="p">.</span><span class="n">Handles</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">D3D12_SHADER_RESOURCE_VIEW_DESC</span> <span class="n">srvDesc</span> <span class="o">=</span> <span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">SRVDesc</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">DX12</span><span class="o">::</span><span class="n">Device</span><span class="o">-&gt;</span><span class="n">CreateShaderResourceView</span><span class="p">(</span><span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">Resource</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">srvDesc</span><span class="p">,</span> <span class="n">alloc</span><span class="p">.</span><span class="n">Handles</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Then every CPU frame we just need to fill that buffer with fresh data:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">DebugInfo</span> <span class="n">debugInfo</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">PrintBuffer</span> <span class="o">=</span> <span class="n">PrintBuffer</span><span class="p">.</span><span class="n">SRV</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">PrintBufferSize</span> <span class="o">=</span> <span class="n">uint32</span><span class="p">(</span><span class="n">PrintBuffer</span><span class="p">.</span><span class="n">InternalBuffer</span><span class="p">.</span><span class="n">Size</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">CursorXY</span> <span class="o">=</span> <span class="p">{</span> <span class="n">cursorX</span><span class="p">,</span> <span class="n">cursorY</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">DebugInfoBuffer</span><span class="p">.</span><span class="n">MapAndSetData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">debugInfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">debugInfo</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
</span></span></code></pre></div><p>In the shader it&rsquo;s no fuss at all to get the buffer through <code>ResourceDescriptorHeap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// In a header file shared between shaders and C++:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">DebugInfo</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DescriptorIndex</span> <span class="n">PrintBuffer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShaderUint</span> <span class="n">PrintBufferSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ShaderUint2</span> <span class="n">CursorXY</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">SharedConstant_</span> <span class="n">DescriptorIndex</span> <span class="n">MagicDebugBufferIndex</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// In ShaderDebug.hlsli
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">DebugInfo</span> <span class="nf">GetDebugInfo</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ByteAddressBuffer</span> <span class="n">debugBuffer</span> <span class="o">=</span> <span class="n">ResourceDescriptorHeap</span><span class="p">[</span><span class="n">MagicDebugBufferIndex</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">debugBuffer</span><span class="p">.</span><span class="n">Load</span><span class="o">&lt;</span><span class="n">DebugInfo</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In addition to the index of the print buffer descriptor, I have the mouse cursor position in there as well since that&rsquo;s useful for &ldquo;print data for the pixel under the cursor&rdquo; scenarios. But you could add other things too: debug flags or floats that you can use in the shader without having to explicitly add new ones, frame indices or other program state, whatever you want.</p>
<h2 id="dealing-with-the-string-problem">Dealing With The String Problem<a href="#dealing-with-the-string-problem" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Now that we have access to our magic debug info buffer which then gives us access to our print buffer, we can start building up the functionality needed to write data into that buffer. This is where things unfortunately get rather dicey in HLSL, which has no native support for working with strings or even a <code>char</code> type. The SPIR-V printf kinda works around this, since you only pass a literal to a <code>printf</code> intrinsic and then the compiler handles the rest. But this does not help us at all if we need to do our own processing of the string, which we need to do for our home-grown printf implementation. One workaround I&rsquo;ve used myself and seen used elsewhere is to declare <code>uint</code> arrays of character literals, and pass those around. This works nicely enough with existing language support, but it&rsquo;s about as ugly as you&rsquo;d imagine:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="n">uint</span> <span class="n">printStr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                          <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">DebugPrint</span><span class="p">(</span><span class="n">printStr</span><span class="p">);</span>
</span></span></code></pre></div><p>While this is not unworkable, it&rsquo;s very ugly and takes significantly longer to write strings this way. You could potentially use editor tooling to help alleviate this&hellip; in fact I used to have a Sublime Text add-in that I wrote which could convert back and forth between a string literal and an array of char literals. But that&rsquo;s at best a band aid.</p>
<p>Another alternative would be to write or use some kind of custom pre-processor that can extract the string literals from the shader and replace them with something else. This could seamlessly replace a literal with that <code>uint</code> array monstrosity above. Or you could potentially take it even further and replace the string with some kind of hash or token, and then store the string somewhere accessible on the CPU side so that it can be looked up when the print buffer is read back and resolved. That last approach could potentially be quite a bit more efficient on the shader side by drastically reducing the amount of data that needs to be written to the buffer, but it is more complicated. In particular adding any kind of shader pre-processing is a heavy-handed step, and the decision to take on the associated burdens should not be treated lightly. Some engines have already chosen to do this for other reasons, in which case adding string literal handling would be a smaller incremental cost.</p>
<p>Really neither of these solutions are ideal, particularly for a smaller codebase being used for experimenting or messing around. I filed a <a href="https://github.com/microsoft/DirectXShaderCompiler/issues/4015">GitHub issue on the DXC repo</a> with a request for better string support back in October 2021, but as of January 2024 it still has not had a resolution.</p>
<h3 id="a-cursed-path">A Cursed Path<a href="#a-cursed-path" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p><em>Update 05/04/2025: as of the February 2025 release of DXC, the compiler will no longer let you pass a string literal as an argument for a templated function. This new error message was a <a href="https://github.com/microsoft/DirectXShaderCompiler/issues/6877">fix</a> for the below code pattern causing crashes in SPIR-V codegen. That means the code below no longer works. While this is not entirely surprising since it was a hack, it&rsquo;s still disappointing since there&rsquo;s still there&rsquo;s no way to work with string literals in HLSL. Please comment on <a href="https://github.com/microsoft/hlsl-specs/issues/279">this feature request</a> to indicate your support if you care about strings in HLSL.</em></p>
<p><em>Before I go any further I&rsquo;ll warn that this code is going to be ugly, and is almost certainly relying on unintended functionality in the compiler that just happened to be exposed through templates. It&rsquo;s very possible this won&rsquo;t work in the future, so I would not rely on this for anything critical and perhaps it would be safest to avoid it altogether. You&rsquo;ve been warned!</em></p>
<p>While experimenting with <a href="https://devblogs.microsoft.com/directx/announcing-hlsl-2021/">HLSL 2021</a>, I stumbled upon a way to use a combination of template and macro hacks to work with string literals and extract the characters as integers. It turns out that literals can be passed to templated functions that expect an array of type <code>T</code>, where <code>T</code> is ultimately <code>char</code> even though that type is intentionally not exposed. While indexing into that array doesn&rsquo;t seem to work, we can make a simple <code>strlen</code> implementation that just uses the size of the array to determine the length of the string literal:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">uint</span> <span class="n">StrLen</span><span class="p">(</span><span class="n">T</span> <span class="n">str</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Includes the null terminator
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="n">N</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Nice! As for indexing into the characters of the literal, while we can&rsquo;t do that from a templated function we <em>can</em> do it by indexing into the literal itself. For example, <code>&quot;Hello&quot;[2]</code>. This means we have to resort to a loop in a macro, but for me this is an acceptable cost of doing business. But we still have one more problem: because of the way that <code>char</code> has been disabled inside of DXC, you can&rsquo;t actually do useful things with it. This includes any arithmetic, or even casting it to an <code>int</code> or <code>uint</code>. However it turns that there is <em>one</em> thing you can do with it, which is compare it to another character literal. Therefore <code>&quot;Hello&quot;[2] == 'l'</code> will evaluate to <code>true</code>. While this isn&rsquo;t immediately useful, it <em>does</em> mean we can write the world&rsquo;s most cursed <code>CharToUint</code> function:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">uint</span> <span class="n">CharToUint</span><span class="p">(</span><span class="n">in</span> <span class="n">T</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">65</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">66</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;C&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">67</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;D&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">68</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;E&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">69</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">70</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;G&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">71</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// ...and about 90 more cases to handle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span></code></pre></div><p>Putting it all together, we can finally make a macro that can process the string literal one at a time so that it can be packed into a buffer:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define DebugPrint(str, ...) do {                            \
</span></span></span><span class="line"><span class="cl"><span class="cp">    ShaderDebug::DebugPrinter printer;                       \
</span></span></span><span class="line"><span class="cl"><span class="cp">    printer.Init();                                          \
</span></span></span><span class="line"><span class="cl"><span class="cp">    const uint strLen = ShaderDebug::StrLen(str);            \
</span></span></span><span class="line"><span class="cl"><span class="cp">    for(uint i = 0; i &lt; strLen; ++i)                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">        printer.AppendChar(ShaderDebug::CharToUint(str[i])); \
</span></span></span><span class="line"><span class="cl"><span class="cp">    printer.StringSize = printer.ByteCount;                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">    printer.AppendArgs(__VA_ARGS__);                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">    printer.Commit(ShaderDebug::GetDebugInfo());             \
</span></span></span><span class="line"><span class="cl"><span class="cp">} while(0)
</span></span></span></code></pre></div><p>Amazing? Terrible? Helpful? Morally dangerous? I&rsquo;m honestly not sure, you&rsquo;ll have to decide for yourself.</p>
<h2 id="packing-it-all-into-a-buffer">Packing It All Into A Buffer<a href="#packing-it-all-into-a-buffer" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Now that we&rsquo;ve covered strings, we&rsquo;re ready to look how the string and any arguments get packed into our print buffer. You may have noticed that in my <code>DebugPrint</code> macro, I&rsquo;ve got a <code>DebugPrinter</code> type that&rsquo;s doing most of the heavy lifting. Let&rsquo;s hook at how that&rsquo;s written:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">DebugPrinter</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">uint</span> <span class="n">BufferSize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="k">const</span> <span class="n">uint</span> <span class="n">BufferSizeInBytes</span> <span class="o">=</span> <span class="n">BufferSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">InternalBuffer</span><span class="p">[</span><span class="n">BufferSize</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">ByteCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">StringSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">ArgCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">Init</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BufferSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">InternalBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ByteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">StringSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ArgCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="nf">CurrBufferIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ByteCount</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="nf">CurrBufferShift</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="n">ByteCount</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">AppendChar</span><span class="p">(</span><span class="n">uint</span> <span class="n">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ByteCount</span> <span class="o">&lt;</span> <span class="n">BufferSizeInBytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">InternalBuffer</span><span class="p">[</span><span class="n">CurrBufferIndex</span><span class="p">()]</span> <span class="o">|=</span> <span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">CurrBufferShift</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">            <span class="n">ByteCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Basically we have an internal buffer of <code>uint</code> that we use to store the converted characters, packed as 1 of the 4 bytes in the <code>uint</code>. As we loop over the string literal, we just keep incrementing <code>ByteCount</code> and packing in the data. However for a <code>printf</code> we also want to be able to handle arguments, that way we can print integers and floats and the like. For those we will also pack the data into the internal buffer, but we will also store a special code before each argument to provide the CPU code with the type and size of the argument:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">ArgCode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Uint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Uint2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Uint3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Uint4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Int</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Int2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Int3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Int4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Float</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Float2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Float3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrint_Float4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">NumDebugPrintArgCodes</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">uint</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">AppendArgWithCode</span><span class="p">(</span><span class="n">ArgCode</span> <span class="n">code</span><span class="p">,</span> <span class="n">T</span> <span class="n">arg</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ByteCount</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">BufferSizeInBytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ArgCount</span> <span class="o">&gt;=</span> <span class="n">MaxDebugPrintArgs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">AppendChar</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">elem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">elem</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">AppendChar</span><span class="p">(</span><span class="n">asuint</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">elem</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">ArgCount</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>To make things work nicely with the arguments passed to the macro, we have some trampoline functions that append each argument individually and pass the correct code to <code>AppendArgWithCode</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AppendArg</span><span class="p">(</span><span class="n">uint</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArgWithCode</span><span class="p">(</span><span class="n">DebugPrint_Uint</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AppendArg</span><span class="p">(</span><span class="n">uint2</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">y</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArgWithCode</span><span class="p">(</span><span class="n">DebugPrint_Uint2</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AppendArg</span><span class="p">(</span><span class="n">uint3</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">z</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArgWithCode</span><span class="p">(</span><span class="n">DebugPrint_Uint3</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// More of these for floats, signed integers, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">AppendArgs</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T0</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">AppendArgs</span><span class="p">(</span><span class="n">T0</span> <span class="n">arg0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">AppendArgs</span><span class="p">(</span><span class="n">T0</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">T1</span> <span class="n">arg1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T0</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">AppendArgs</span><span class="p">(</span><span class="n">T0</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">T1</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">arg2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">AppendArg</span><span class="p">(</span><span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// More of these for higher arg counts
</span></span></span></code></pre></div><p>This allows the macro to just do <code>printer.AppendArgs(__VA_ARGS__);</code> and it all works.</p>
<p>Finally we have one last <code>Commit()</code> method on <code>DebugPrinter</code> that actually stores everything into the <code>RWByteAddressBuffer</code> along with a special header:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">Commit</span><span class="p">(</span><span class="n">in</span> <span class="n">DebugInfo</span> <span class="n">debugInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ByteCount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Round up to the next multiple of 4 since we work with 4-byte alignment for each print
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ByteCount</span> <span class="o">=</span> <span class="p">((</span><span class="n">ByteCount</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RWByteAddressBuffer</span> <span class="n">printBuffer</span> <span class="o">=</span> <span class="n">ResourceDescriptorHeap</span><span class="p">[</span><span class="n">debugInfo</span><span class="p">.</span><span class="n">PrintBuffer</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Increment the atomic counter to allocate space to store the bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">uint</span> <span class="n">numBytesToWrite</span> <span class="o">=</span> <span class="n">ByteCount</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DebugPrintHeader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printBuffer</span><span class="p">.</span><span class="n">InterlockedAdd</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numBytesToWrite</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Account for the atomic counter at the beginning of the buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">numBytesToWrite</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">debugInfo</span><span class="p">.</span><span class="n">PrintBufferSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Store the header
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">DebugPrintHeader</span> <span class="n">header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">header</span><span class="p">.</span><span class="n">NumBytes</span> <span class="o">=</span> <span class="n">ByteCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">header</span><span class="p">.</span><span class="n">StringSize</span> <span class="o">=</span> <span class="n">StringSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">header</span><span class="p">.</span><span class="n">NumArgs</span> <span class="o">=</span> <span class="n">ArgCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">printBuffer</span><span class="p">.</span><span class="n">Store</span><span class="o">&lt;</span><span class="n">DebugPrintHeader</span><span class="o">&gt;</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">DebugPrintHeader</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Store the buffer data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ByteCount</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">printBuffer</span><span class="p">.</span><span class="n">Store</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uint</span><span class="p">)),</span> <span class="n">InternalBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>In <code>Commit()</code> we&rsquo;re assuming there&rsquo;s a counter at the start of the print buffer that indicates how many bytes have been written to it. By atomically incrementing that counter we can safely &ldquo;allocate&rdquo; some space for our print data, and also ensure that enough space is left so that we can early-out if the buffer is full. Once the counter is incremented we fill out our small header and write that first, then write the contents of the internal buffer one <code>uint</code> at a time.</p>
<p>While there&rsquo;s some complexity and ugliness here that we need to hide in an included file, actually doing a print in the shader code is about as easy as it gets:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">ComputeColor</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">DebugPrint</span><span class="p">(</span><span class="s">&#34;The color is {0}&#34;</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
</span></span></code></pre></div><p>Since we&rsquo;re embedding the argument type as a code in the buffer, there&rsquo;s no need for printf-style format specifiers and we can instead use argument IDs like in <a href="https://en.cppreference.com/w/cpp/utility/format/format">std::format</a> or C#&rsquo;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.string.format?view=net-8.0">String.Format</a>.</p>
<h2 id="reading-back-on-the-cpu">Reading Back On The CPU<a href="#reading-back-on-the-cpu" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>In order to have the CPU process all of the print data that&rsquo;s been generated on the GPU, we need to issue some commands that copies the print buffer to a CPU-accessible readback buffer:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">EndRender</span><span class="p">(</span><span class="n">ID3D12GraphicsCommandList7</span><span class="o">*</span> <span class="n">cmdList</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PIXMarker</span> <span class="n">marker</span><span class="p">(</span><span class="n">cmdList</span><span class="p">,</span> <span class="s">&#34;ShaderDebug - EndRender&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">DX12</span><span class="o">::</span><span class="n">Barrier</span><span class="p">(</span><span class="n">cmdList</span><span class="p">,</span> <span class="n">PrintBuffer</span><span class="p">.</span><span class="n">WriteToReadBarrier</span><span class="p">(</span> <span class="p">{</span> <span class="p">.</span><span class="n">SyncAfter</span> <span class="o">=</span> <span class="n">D3D12_BARRIER_SYNC_COPY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                             <span class="p">.</span><span class="n">AccessAfter</span> <span class="o">=</span> <span class="n">D3D12_BARRIER_ACCESS_COPY_SOURCE</span> <span class="p">}</span> <span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ReadbackBuffer</span><span class="o">&amp;</span> <span class="n">readbackBuffer</span> <span class="o">=</span> <span class="n">PrintReadbackBuffers</span><span class="p">[</span><span class="n">DX12</span><span class="o">::</span><span class="n">CurrentCPUFrame</span> <span class="o">%</span> <span class="n">DX12</span><span class="o">::</span><span class="n">RenderLatency</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">cmdList</span><span class="o">-&gt;</span><span class="n">CopyResource</span><span class="p">(</span><span class="n">readbackBuffer</span><span class="p">.</span><span class="n">Resource</span><span class="p">,</span> <span class="n">PrintBuffer</span><span class="p">.</span><span class="n">Resource</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Doing the copy to the readback buffer allows us to map and read the oldest generated print buffer data every frame so that we can process it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="n">DX12</span><span class="o">::</span><span class="n">CurrentCPUFrame</span> <span class="o">&gt;=</span> <span class="n">DX12</span><span class="o">::</span><span class="n">RenderLatency</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ReadbackBuffer</span><span class="o">&amp;</span> <span class="n">readbackBuffer</span> <span class="o">=</span> <span class="n">PrintReadbackBuffers</span><span class="p">[(</span><span class="n">DX12</span><span class="o">::</span><span class="n">CurrentCPUFrame</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">DX12</span><span class="o">::</span><span class="n">RenderLatency</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">DebugPrintReader</span> <span class="nf">printReader</span><span class="p">(</span><span class="n">readbackBuffer</span><span class="p">.</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">uint8</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">uint32</span><span class="p">(</span><span class="n">readbackBuffer</span><span class="p">.</span><span class="n">Size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">printReader</span><span class="p">.</span><span class="n">HasMoreData</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">DebugPrintHeader</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="n">DebugPrintHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="n">printReader</span><span class="p">.</span><span class="n">Consume</span><span class="o">&lt;</span><span class="n">DebugPrintHeader</span><span class="o">&gt;</span><span class="p">(</span><span class="n">DebugPrintHeader</span><span class="p">{});</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">NumBytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">printReader</span><span class="p">.</span><span class="n">HasMoreData</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">NumBytes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">formatStr</span> <span class="o">=</span> <span class="n">printReader</span><span class="p">.</span><span class="n">ConsumeString</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">StringSize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">formatStr</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">NumArgs</span> <span class="o">&gt;</span> <span class="n">MaxDebugPrintArgs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">argStrings</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="n">header</span><span class="p">.</span><span class="n">NumArgs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">uint32</span> <span class="n">argIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argIdx</span> <span class="o">&lt;</span> <span class="n">header</span><span class="p">.</span><span class="n">NumArgs</span><span class="p">;</span> <span class="o">++</span><span class="n">argIdx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="n">ArgCode</span> <span class="n">argCode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ArgCode</span><span class="p">)</span><span class="n">printReader</span><span class="p">.</span><span class="n">Consume</span><span class="o">&lt;</span><span class="n">uint8</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">argCode</span> <span class="o">&gt;=</span> <span class="n">NumDebugPrintArgCodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="n">uint32</span> <span class="n">argSize</span> <span class="o">=</span> <span class="n">ArgCodeSizes</span><span class="p">[</span><span class="n">argCode</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">printReader</span><span class="p">.</span><span class="n">HasMoreData</span><span class="p">(</span><span class="n">argSize</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">argStr</span> <span class="o">=</span> <span class="n">MakeArgString</span><span class="p">(</span><span class="n">printReader</span><span class="p">,</span> <span class="n">argCode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">ReplaceStringInPlace</span><span class="p">(</span><span class="n">formatStr</span><span class="p">,</span> <span class="n">ArgPlaceHolders</span><span class="p">[</span><span class="n">argIdx</span><span class="p">],</span> <span class="n">argStr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">GlobalApp</span><span class="o">-&gt;</span><span class="n">AddToLog</span><span class="p">(</span><span class="n">formatStr</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">readbackBuffer</span><span class="p">.</span><span class="n">Unmap</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The processing involves a loop that iterates until all of the print data in the buffer has been processed. For each iteration of the loop, we pull out a <code>DebugPrintHeader</code> that marks the beginning of a single <code>DebugPrint</code> call from a single thread of a shader. That header is then used to gather the actual format string, as well as the number of argument. Each argument is extracted using the code we embedded on the shader side, and a stringified version of the argument is then inserted into the original print string to replace the argument index. The final expanded string with arguments is then passed on to my simple log system, but at that point you could do whatever you&rsquo;d like with it. In my case the log outputs to a simple ImGui text window, but you can get as fancy as you want.</p>
<h2 id="going-beyond-printf">Going Beyond Printf<a href="#going-beyond-printf" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Having a shader printf is already hugely valuable and worthwhile, but once you have this sort of infrastructure in place there&rsquo;s all kinds of things you can do with it. For example you could build a higher-level assert mechanism on top of <code>DebugPrint</code> that logs information when a condition isn&rsquo;t met. The <code>__FILE__</code> and <code>__LINE__</code> predefined macros work in DXC, so you could include that along with the condition itself in the log message. Unfortunately there&rsquo;s no way I know of to get any kind of &ldquo;stack strace&rdquo;, so you&rsquo;re on your own for that. There also isn&rsquo;t a standard <code>__debugbreak()</code> intrinsic or anything like that for shaders. The best you can do is enter an infinite loop or <a href="https://github.com/sawickiap/ShaderCrashingAssert">force a deliberate page fault</a>, and hope that your GPU crash reporting systems catch it appropriately.</p>
<p>Another common trick is to implement shader-driven debug rendering. If you have a CPU-based debug renderer then it&rsquo;s pretty straightforward to add special &ldquo;print&rdquo; code that can be detected on the CPU, which can then extract and forward the draw arguments to the debug renderer. The main downside of doing it this way is that you&rsquo;ll need to accept a few frames of latency between when the shader draws and when it shows up. For a lot of cases this is totally fine, but it can be a dealbreaker for certain debugging scenarios. A zero-latency alternative is to have a separate buffer for debug draws, and run a compute shader to process that and <a href="https://www.gijskaerts.com/wordpress/?p=190">convert it into indirect draw commands</a>.</p>
<p>Once you take it to the extreme, your print system can basically be a deferred message passing interface between your shaders and the engine. This could potentially be used for all kinds of powerful or wacky things if you&rsquo;re sufficiently motivated. For example, you could replicate a subset of the Dear ImGui interface in your shader, <a href="https://twitter.com/dieter_debaets/status/1742201258398609786">and give your shaders the ability to draw their own debug UI</a>. The sky is the limit!</p>
<h2 id="cr-lf">CR LF<a href="#cr-lf" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>That&rsquo;s it for the article! Hopefully what I&rsquo;ve described is helpful for people implementing similar systems, or provides some ideas for how to improve existing ones. Good luck, and happy printing!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>HLSL has actually had a <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/printf">printf intrinsic</a> since the D3D11 days. Unfortunately no driver or tool has ever supported it outside of the old software REF device, which was really only used for validation.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://therealmjp.github.io/tags/graphics">Graphics</a></span><span class="tag"><a href="https://therealmjp.github.io/tags/dx12">DX12</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>3763 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2024-01-06 16:00 -0800</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://therealmjp.github.io/posts/to-earlyz-or-not-to-earlyz/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>To Early-Z, or Not To Early-Z</span>
			</a>
			<a class="prev-post" href="https://therealmjp.github.io/posts/gpu-memory-pool/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>GPU Memory Pools in D3D12</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://utteranc.es/client.js"
        repo="TheRealMJP/TheRealMJP.github.io"
        issue-term="title"
        label="comments"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2025 <a href="https://therealmjp.github.io/">MJP</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://therealmjp.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://therealmjp.github.io/js/main.min.6e4a8d6406e68b5f99eb4fd82c6e3eaa5aa471527d2d301aceaecdfefdd04bc9.js" integrity="sha256-bkqNZAbmi1+Z60/YLG4+qlqkcVJ9LTAazq7N/v3QS8k="></script>



</body>

</html>
