<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta itemprop="name" content="Bindless Texturing for Deferred Rendering and Decals">
<meta itemprop="description" content="https://github.com/TheRealMJP/DeferredTexturing
https://github.com/TheRealMJP/DeferredTexturing/releases (Precompiled Binaries)
To Bind, or Not To Bind Unless you&rsquo;ve been in a coma for the past year, you&rsquo;ve probably noticed that there&rsquo;s a lot of buzz and excitement around the new graphics API&rsquo;s that are available for PC and mobile. One of the biggest changes brought by both D3D12 and Vulkan is that they&rsquo;ve ditched the old slot-based system for binding resources that&rsquo;s been in use since&hellip;forever. In place of the old system, both API&rsquo;s have a adopted a new model[1] based around placing opaque resource descriptors in contiguous ranges of GPU-accessible memory.">
<meta itemprop="datePublished" content="2016-03-25T08:39:36&#43;00:00" />
<meta itemprop="dateModified" content="2016-03-25T08:39:36&#43;00:00" />
<meta itemprop="wordCount" content="7534">



<meta itemprop="keywords" content="DirectX 12,Graphics," /><meta property="og:title" content="Bindless Texturing for Deferred Rendering and Decals" />
<meta property="og:description" content="https://github.com/TheRealMJP/DeferredTexturing
https://github.com/TheRealMJP/DeferredTexturing/releases (Precompiled Binaries)
To Bind, or Not To Bind Unless you&rsquo;ve been in a coma for the past year, you&rsquo;ve probably noticed that there&rsquo;s a lot of buzz and excitement around the new graphics API&rsquo;s that are available for PC and mobile. One of the biggest changes brought by both D3D12 and Vulkan is that they&rsquo;ve ditched the old slot-based system for binding resources that&rsquo;s been in use since&hellip;forever. In place of the old system, both API&rsquo;s have a adopted a new model[1] based around placing opaque resource descriptors in contiguous ranges of GPU-accessible memory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://therealmjp.github.io/posts/bindless-texturing-for-deferred-rendering-and-decals/" />
<meta property="article:published_time" content="2016-03-25T08:39:36+00:00" />
<meta property="article:modified_time" content="2016-03-25T08:39:36+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Bindless Texturing for Deferred Rendering and Decals"/>
<meta name="twitter:description" content="https://github.com/TheRealMJP/DeferredTexturing
https://github.com/TheRealMJP/DeferredTexturing/releases (Precompiled Binaries)
To Bind, or Not To Bind Unless you&rsquo;ve been in a coma for the past year, you&rsquo;ve probably noticed that there&rsquo;s a lot of buzz and excitement around the new graphics API&rsquo;s that are available for PC and mobile. One of the biggest changes brought by both D3D12 and Vulkan is that they&rsquo;ve ditched the old slot-based system for binding resources that&rsquo;s been in use since&hellip;forever. In place of the old system, both API&rsquo;s have a adopted a new model[1] based around placing opaque resource descriptors in contiguous ranges of GPU-accessible memory."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Bindless Texturing for Deferred Rendering and Decals</title>
	<link rel="stylesheet" href="https://therealmjp.github.io/css/style.min.9ae64a8094d0d100100f0725503238784f798a59c57003700be4d8b0645124e9.css" integrity="sha256-muZKgJTQ0QAQDwclUDI4eE95ilnFcANwC+TYsGRRJOk=">
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://therealmjp.github.io/">The Danger Zone</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://therealmjp.github.io/posts/">Posts</a>
				<a href="https://therealmjp.github.io/about/">About</a>
				<a href="https://therealmjp.github.io/publications/">Publications</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/TheRealMJP" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://twitter.com/mynameismjp" target="_blank" rel="noopener me" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="mailto:mpettineo@gmail.com" target="_blank" rel="noopener me" title="Email"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://therealmjp.github.io/posts/">Posts</a></li>
			<li><a href="https://therealmjp.github.io/about/">About</a></li>
			<li><a href="https://therealmjp.github.io/publications/">Publications</a></li>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Mar 25, 2016</span></div>
				<h1>Bindless Texturing for Deferred Rendering and Decals</h1>
			</header>
			<div class="content">
				<p><img src="https://mynameismjp.files.wordpress.com/2016/03/title.png" alt="Title Image"></p>
<p><a href="https://github.com/TheRealMJP/DeferredTexturing">https://github.com/TheRealMJP/DeferredTexturing</a></p>
<p><a href="https://github.com/TheRealMJP/DeferredTexturing/releases">https://github.com/TheRealMJP/DeferredTexturing/releases</a> (Precompiled Binaries)</p>
<h2 id="to-bind-or-not-to-bind">To Bind, or Not To Bind<a href="#to-bind-or-not-to-bind" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Unless you&rsquo;ve been in a coma for the past year, you&rsquo;ve probably noticed that there&rsquo;s a lot of buzz and excitement around the new graphics API&rsquo;s that are available for PC and mobile. One of the biggest changes brought by both D3D12 and Vulkan is that they&rsquo;ve ditched the old slot-based system for binding resources that&rsquo;s been in use since&hellip;forever. In place of the old system, both API&rsquo;s have a adopted a <a href="https://software.intel.com/en-us/articles/introduction-to-resource-binding-in-microsoft-directx-12">new model</a>[1] based around placing opaque resource descriptors in contiguous ranges of GPU-accessible memory. The new model has the potential to be more efficient, since a lot of hardware (most notably AMD&rsquo;s GCN-based GPU&rsquo;s) can read their descriptors straight from memory instead of having to keep them in physical registers. So instead of having the driver take a slot-based model and do behind-the-scenes gymnastics to put the appropriate descriptors into tables that the shader can use, the app can just put the descriptors in a layout that works right from the start.</p>
<p>The new style of providing resources to the GPU is often referred to as &ldquo;bindless&rdquo;, since you&rsquo;re no longer restricted to explicitly binding textures or buffers through dedicated API functions. The term &ldquo;bindless&rdquo; originally comes from Nvidia, who were the first to <a href="http://developer.download.nvidia.com/opengl/tutorials/bindless_graphics.pdf">introduce the concept</a>[2] through their <a href="http://developer.download.nvidia.com/opengl/specs/GL_NV_bindless_texture.txt">NV_bindless_texture</a>[3] extension for OpenGL. Their material shows some serious reductions in CPU overhead by skipping standard resource binding, and instead letting the app place 64-bit descriptor handles (most likely they&rsquo;re actually pointers to descriptors) inside of uniform buffers. One major difference between Nvidia bindless and D3D12/Vulkan bindless is that the new APIs don&rsquo;t allow you to simply put descriptor handles inside of constant/uniform buffers. Instead, they require you to manually specify (through a root signature) how you&rsquo;ll organize your tables of descriptors for a shader. It might seem more complicated the Nvidia extension, but doing it this way has a big advantage: it lets D3D12 still support hardware that has no support (or limited support) for pulling descriptors from memory. It also still allows you to go full-on Nvidia-style bindless via support for unbounded texture arrays in HLSL. With unbounded arrays you can potentially put all of your descriptors in one giant table, and then index into that array using values from root constants/constant buffers/structured buffers/etc. This basically lets you treat an integer the same as a &ldquo;handle&rdquo; in Nvidia&rsquo;s approach, with the added benefit that you don&rsquo;t need to actually store a full 64-bit integer. Not only can this be really efficient, but it also opens the door to new rendering techniques that use GPU-generated values to determine which textures to fetch from.</p>
<h2 id="deferred-texturing">Deferred Texturing<a href="#deferred-texturing" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>One such use case for bindless textures is deferred texturing. The concept is pretty straightforward: instead of writing out a G-Buffer containing all of the material parameters required for shading, you instead write out your interpolated UV&rsquo;s as well as a material ID. Then during your deferred pass you can use your material ID to figure out which textures you need to sample, and use the UV&rsquo;s from your G-Buffer to actually sample them. The main benefit is that you can ensure that your textures are only sampled for visible pixels, without worrying about overdraw or quad packing. Depending on your approach, you may also be able to save on some G-Buffer space by virtue of not having to cram every material parameter in there. In practice you actually need more than just UV and material ID. For normal mapping you need your full tangent frame, which at minimum requires a quaternion. For mipmaps and anisotropic filtering we also need the screen-space derivatives of our UV&rsquo;s. These can computed in the pixel shader and then explicitly stored in the G-Buffer, or you can compute them from G-Buffer as long as you&rsquo;re willing to live with occasional artifacts. Nathan Reed has a <a href="http://www.reedbeta.com/blog/2014/03/25/deferred-texturing/">nice write-up</a>[4] on his blog discussing the various possibilities for G-Buffer layouts, so I would suggest reading through his article for some more details.</p>
<p>The place where bindless helps is in the actual sampling of the material textures during the deferred lighting phase. By putting all of your texture descriptors into one big array, the lighting pass can index into that array in order to sample the textures for any given material. All you need is a simple mapping of material ID -&gt; texture indices, which you can do by indexing into a structured buffer. Of course it&rsquo;s not really <em>required</em> to have bindless in order to pull this off. If you&rsquo;re willing to stuff all of your textures into a big texture array, then you could achieve the same thing on D3D10-level hardware. Or if you use virtual mapping, then it&rsquo;s pretty trivial to implement since everything&rsquo;s already coming from big texture atlases. In fact, the virtual mapping approach has already been used in a shipping game, and was <a href="http://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">described at SIGGRAPH last year</a>[5][6]. That said, the bindless approach is probably the easiest to get running and also places the least constraints on existing pipelines and assets.</p>
<h2 id="go-go-gadget-d3d12">Go Go Gadget D3D12!<a href="#go-go-gadget-d3d12" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>As a way to test out the brand-new D3D12 version of my sample framework, I decided to have a go at writing a simple implementation of a deferred texturing renderer. It seemed like a good way to get familiar with some of the new features offered by D3D12, while also making sure that the new version of my sample framework was ready for prime-time. I also hoped that I could gain a better understanding of some of the practical issues involved in implementing deferred texturing, and use the experience to judge whether or not it might be a appealing choice for future projects.</p>
<p>Here&rsquo;s a quick breakdown of how I ultimately set up my renderer:</p>
<ul>
<li>Bin lights and decals into clusters
<ul>
<li>16x16 tiles aligned to screen space, 16 linearly-partitioned depth tiles</li>
</ul>
</li>
<li>Render sun and spotlight shadows
<ul>
<li>4 2048x2048 cascaded shadow maps for the sun</li>
<li>1024x1024 standard shadow maps for each spotlight</li>
</ul>
</li>
<li>Render scene to the G-Buffer
<ul>
<li>Depth (32bpp)</li>
<li>Tangent frame as a <a href="http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html">packed quaternion</a>[7]  (32bpp)</li>
<li>Texture coordinates (32bpp)</li>
<li>Depth gradients (32bpp)</li>
<li>(Optional) UV gradients (64bpp)</li>
<li>Material ID  (8bpp)
<ul>
<li>7-bit Material index</li>
<li>1-bit for tangent frame handedness</li>
</ul>
</li>
</ul>
</li>
<li>If MSAA is not enabled:
<ul>
<li>Run a deferred compute shader that perfoms deferred shading for all pixels
<ul>
<li>Read attributes from G-Buffer</li>
<li>Use material ID to get texture indices, and use those indices to index into descriptor tables</li>
<li>Blend decals into material properties</li>
</ul>
</li>
<li>Render the sky to the output texture, using the depth buffer for occlusion</li>
</ul>
</li>
<li>Otherwise if MSAA is enabled
<ul>
<li>Detect &ldquo;edge&rdquo; pixels requiring per-sample shading using Material ID</li>
<li>Classify 8x8 tiles as having either having edges or having no edges</li>
<li>Render the sky to an MSAA render target texture, using the depth buffer for occlusion</li>
<li>Run a deferred compute shader for non-edge tiles, shading only 1 subsample per pixel</li>
<li>Run a deferred compute shader for edge tiles, shading 1 subsample for non-edge pixels and all subsamples for edge pixels</li>
<li>Resolve MSAA subsamples to a non-MSAA texture</li>
</ul>
</li>
<li>Post-processing</li>
<li>Present</li>
</ul>
<p>In order to have another reference point for evaluating quality and performance, I also decided to implement a <a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf">clustered forward</a>[8] path side-by-side with the deferred renderer:</p>
<ul>
<li>Bin lights into clusters (16x16 tiles aligned to screen space, 16 linearly-partitioned depth tiles)</li>
<li>Render sun and spotlight shadows</li>
<li>(optional) Render scene depth prepass</li>
<li>Render scene with full shading
<ul>
<li>Read from material textures</li>
<li>Blend decals into material properties</li>
<li>Apply sunlight and spotlights</li>
</ul>
</li>
<li>if MSAA is enabled
<ul>
<li>Resolve MSAA subsamples to a non-MSAA texture</li>
</ul>
</li>
<li>Post-processing</li>
<li>Present</li>
</ul>
<h2 id="light-clusteringbinning">Light Clustering/Binning<a href="#light-clusteringbinning" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>As you may have already noticed, I used the same clustered approach to binning lights for both the deferred and forward paths. I did this because it was simpler than having two different approaches to light selection, and it also seemed more fair to take that aspect out of the equation when comparing performance. However you could obviously use whatever approach you&rsquo;d like for binning lights when using deferred texturing, such as classic light bounds rasterization/blending or <a href="https://software.intel.com/en-us/articles/deferred-rendering-for-current-and-future-rendering-pipelines">tile-based subfrustum culling</a>[9].</p>
<p>To implement the actual binning, I used a similar setup to what was described in <a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf">Emil Persson&rsquo;s excellent presentation</a>[8] from SIGGRAPH 2013. If you&rsquo;re not familiar, the basic idea is that you chop up your view frustum into a bunch subfrusta, both in screen-space XY as well as along the Z axis. This essentially looks like a voxel grid, except warped to fit inside the frustum shape of a perspective projection. This is actually rather similar to the approach used in tiled deferred or <a href="http://www.slideshare.net/takahiroharada/forward-34779335">Forward+</a>[10] rendering, except that you also bucket along Z instead of fitting each subfrustum to the depth buffer. This can be really nice for forward rendering, since it lets you avoid over-including lights for tiles with a large depth range.</p>
<p>In the Avalanche engine they decided to perform their light binning on the CPU, which is feasible since the binning doesn&rsquo;t rely on a depth buffer. Binning on the CPU can make a lot of sense, since a typical GPU approach to culling will often have many redundant calculations across threads and thread groups.It&rsquo;s also possible make it pretty fast through CPU parallelization, as demonstrated by <a href="https://software.intel.com/en-us/articles/forward-clustered-shading">Intel&rsquo;s Clustered Forward Shading sample</a>[11].</p>
<p>For my own implementation I decided that I wanted to stick with the GPU, and so I went with a different approach. Having shipped a game that used a Forward+-style renderer, I&rsquo;m pretty disappointed with the results of using a typical subfrustum plane-based culling scheme in a compute shader. The <a href="http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm">dirty secret</a>[12] of using plane/volume tests for frustum culling is that they&rsquo;re actually quite prone to false positives. The &ldquo;standard&rdquo; test can only exclude when your bounding volume is completely on the wrong side of one or more of your frustum planes. Unfortunately this means that it will fail for cases where the bounding volume intersects multiple planes at points outside the frustum. Even more unfortunate is that this particular case becomes more likely as your bounding volumes become large relative to your frustum, which is typically the case for testing lights against subfrusta. Spotlights are especially bad in this regard, since the wide portion will often intersect the planes of subfrusta that are actually just outside the narrower tip:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/bad_culling.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/bad_culling.png" alt="Bad_Culling"></a></p>
<p>The top-right image shows a 3D perspective view, where you can clearly see that the cone in this situation doesn&rsquo;t actually intersect with the frustum. However if you look at the orthographic views, you can also see that the cone manages to be on both sides of the frustum&rsquo;s right plane. In practice you end up getting results like the following (tiles colored in green are &ldquo;intersecting&rdquo; with the spotlight):</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/spotlight_tile_culling_planes.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/spotlight_tile_culling_planes.png" alt="Spotlight_Tile_Culling_Planes"></a></p>
<p>As you can see, you can end up with a ton of false positives. In fact towards the right we&rsquo;re basically just filling in the screen-aligned AABB of the bounding cone, which turns into a whole lot of wasted work for those pixels.</p>
<p>This drove me nuts on The Order, since our lighting artists liked to pack our levels full of large, shadow-casting spotlights. On the CPU side I would resort to expensive frustum-frustum tests for shadow-casting spotlights, which makes sense when you consider that you can save a lot of CPU and GPU time by culling out an entire shadow map. Unfortunately frustum/frustum wasn&rsquo;t a realistic option for the tiled subfrustum culling that was performed on the GPU, and so for &ldquo;important&rdquo; lights I augmented the intersection test with a 2D mask generated via rasterization of the bounding cone. The results were quite a bit better:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/spotlight_tile_culling_rasterized.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/spotlight_tile_culling_rasterized.png" alt="Spotlight_Tile_Culling_Rasterized"></a></p>
<p>For this demo, I decided to take  what I had done on The Order and move it into 3D by binning into Z buckets as well. Binning in Z is a bit tricky, since you essentially want the equivalent of solid voxelization except in the projected space of your the frustum. Working in projected space rules out some of the common voxelization tricks, and so I ended up going with a simple 2-pass approach. The first pass renders the backfaces of a light&rsquo;s bounding geometry, and marks the light&rsquo;s bit (each cluster stores a bitfield of active lights) in the furthest Z bucket intersected by the current triangle within a given XY bucket. To conservatively estimate the furthest Z bucket, I use pixel shader derivatives to get the depth gradients, and then compute the maximum depth at the corner of the pixel. This generally works OK, but when the depth gradient is large it&rsquo;s possible to extrapolate off the triangle. To minimize the damage in these cases, I compute a view-space AABB of the light on the CPU, and clamp the extrapolated depth to this AABB. After the backfacing pass, the frontfaces are then rendered. This time, the pixel shader computes the minimum depth bucket, and then walks forward along view ray until encountering the bucket that was marked by the backface pass. Here&rsquo;s a visualization of the binning for a single light in my demo:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/light_binning_single.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/light_binning_single.png" alt="Light_Binning_Single"></a></p>
<p>The pixels marked in red are the ones that belong to a cluster where the light is active. The triangle-shaped UI in the bottom right is a visualization that shows the active clusters for the XZ plane located at y=0. This helps you to see how well the clustering is working in Z, which is where the most errors occur in my implementation. Here&rsquo;s another image showing the scene with all (20) lights enabled:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/light_binning_all.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/light_binning_all.png" alt="Light_Binning_All"></a></p>
<p>To do this robustly, you really want to use <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903791(v=vs.85).aspx">conservative rasterization</a>[13]. I have this option in my demo, but unfortunately there are still no AMD GPU&rsquo;s that support the feature. As a fallback, I also support forcing 4x or 8x MSAA modes to reduce the chance that the pixel shader won&rsquo;t be executed for a covered tile. For The Order I used 8x MSAA, and it was never an issue in practice. It would really only be an issue if the light was <em>very</em> small on-screen, in which case you could probably just rasterize a bounding box instead. I should also point out that in my implementation the depth buffer is not used to accelerate the binning process, or to produce more optimally-distributed Z buckets. I implemented it this way so that there would not be additional performance differences when choosing whether or not to enable a Z prepass for the forward rendering path.</p>
<h2 id="the-g-buffer">The G-Buffer<a href="#the-g-buffer" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/g-buffer2.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/g-buffer2.png" alt="G-Buffer"></a></p>
<p>For rendering we&rsquo;re going to need a G-Buffer in which we can store whatever information comes from our vertex data, as well as a material ID that we can use to look up the appropriate textures during the deferred pass. In terms of vertex information, we need both the tangent frame and the UV&rsquo;s in order to sample textures and perform normal mapping. If we assume our tangent frame is an orthonormal basis, we can store it pretty compactly by using a quaternion. <code>R16G16B16A16_SNORM</code> is perfect for this use case, since it covers the expected range and provides great precision. However we can <a href="http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html">crunch it down</a>[7] to 4 bytes per texel if we really want to keep it small (and we do!). The UV&rsquo;s are stored in a 16-bit UNORM format, which gives us plenty of precision as long as we store frac(UV) to keep things between 0 and 1. In the same texture as the UV&rsquo;s I also store screen-space depth gradients in the Z and W components.  After that is an optional 64bpp texture for storing the screen-space UV gradients, which I&rsquo;ll discuss in the next section. Finally, the G-Buffer also has an 8-bit texture for storing a material ID. The MSB of each textel is the handedness bit for the tangent frame, which is used to flip the direction of the bitangent once it&rsquo;s reconstructed from a quaternion. This brings us to a total of 25 bytes per sample when storing UV gradients, and 17 when computing them instead.</p>
<h2 id="uv-and-position-gradients">UV and Position Gradients<a href="#uv-and-position-gradients" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>One issue with deferred texturing is that you can&rsquo;t rely on automatic mip selection via screen-space UV gradients when sampling the material textures. The gradients computed in a pixel shader will be wrong for quads that span multiple triangles, and in a compute shader they&rsquo;re not available at all. The simplest way to solve this is to obtain the gradients in the pixel shader (using ddx/ddy) when rendering the scene to the G-Buffer, and then store those gradients in a texture. Unfortunately this means storing 4 separate values, which requires an additional 8 bytes of data per pixel when using 16-bit precision. It also doesn&rsquo;t help you at all if you require positional gradients during your deferred pass, which can be useful for things like gobos, decals, filterable shadows, or receiver plane shadow bias factors. Storing the full gradients of world or view-space position would be silly, but fortunately we can store depth gradients and use those to reconstruct position gradients. Depth gradients only need 2 values instead of 6, and we can use a 16-bit fixed-point format instead of floating-point. They also have the nice property of being constant across the surface of a plane, which makes them useful for detecting triangle edges.</p>
<p>Both the UV and depth gradients can be computed in the deferred pass by sampling values from neighboring pixels, but in practice I&rsquo;ve found it&rsquo;s actually somewhat tricky to get right. You have to be careful not to &ldquo;walk off the triangle&rdquo;, otherwise you might end up reading UV&rsquo;s from a totally unrelated mesh. Unless of course your triangle is so small that none of your neighbors came from the same triangle, in which case walking off might be your only option. You also have to take care around UV seams, including any you might have created yourself by using frac()!</p>
<p>In my implementation, I decided to always store depth gradients (where &ldquo;depth&rdquo; in this case is the post-projection z/w value stored in the depth buffer)  while supporting an option to either store or compute UV gradients. Doing it this way allowed me to utilize the depth gradients when trying to find suitable neighbor pixels for computing UV gradients, and also ensured that I always had high-quality positional gradients. The material ID was also useful here: by checking that a neighboring pixel used the same material and was also had the same depth gradients, I could be relatively certain that the neighbor was either from the same triangle, or from a coplanar triangle. The shader code for this step can be found <a href="https://github.com/TheRealMJP/DeferredTexturing/blob/master/BindlessDeferred/Deferred.hlsl#L132">here</a>, if you&rsquo;re interested.</p>
<p>To assess the quality, let&rsquo;s look at a visualization showing what the UV gradients look like when using ddx/ddy during forward rendering:</p>
<p><img src="https://mynameismjp.files.wordpress.com/2016/03/uvgradients_stored.png" alt="UVGradients_Stored"></p>
<p>And here&rsquo;s an image showing what computed UV gradients look like:</p>
<p><img src="https://mynameismjp.files.wordpress.com/2016/03/uvgradients_computed.png" alt="UVGradients_Computed"></p>
<p>As you can see there&rsquo;s quite a few places where my algorithm fails to detect neighbors (these pixels are dark), and other places where a neighboring pixel shouldn&rsquo;t have been used at all (these pixels are bright). I&rsquo;m sure the results could be improved with more time and cleverness, but you need to be careful that the amount of work done is enough to offset the cost of just writing out the gradients in the first place. On my GTX 970 it&rsquo;s actually faster to store the gradients than it is to compute them when MSAA is disabled, but then it switches to the other way around once MSAA is turned on.</p>
<p>It&rsquo;s worth noting that <a href="http://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">Sebastian&rsquo;s presentation</a>[5] mentions that they reconstruct UV gradients in their implementation (see page 45),  although you can definitely see some artifacts around triangle edges in their comparison image. They also mention that they use &ldquo;UV distance&rdquo; to detect neighbors, which makes sense considering that they have unique UVs for their virtual texturing.</p>
<h2 id="non-msaa-shading">Non-MSAA Shading<a href="#non-msaa-shading" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>For non-MSAA rendering, the deferred pass is pretty straightforward. First, the G-Buffer attributes are read from their textures and used to compute the original pixel position and gradients. UV gradients are then read from the G-Buffer if present, or otherwise computed from neighboring pixels. The material ID from the G-Buffer is then used to index into a structured buffer that contains one element per material, where each element contains the descriptor indices for the material textures (albedo, normal, roughness, and metallic). These indices are used to index into a large descriptor table containing descriptors for every texture in the scene, so that the appropriate textures can be sampled using the pixel&rsquo;s UV coordinates and derivatives.</p>
<p>Once all of the surface and material parameters are read, they are passed into a function that performs the actual shading. This function will loop over all lights that were binned into the pixel&rsquo;s XYZ cluster, and compute the reflectance for each light source. This requires evaluating the surface BRDF, and also applying a visibility term that comes from the light&rsquo;s 1024x1024 shadow map. The shadow map is sampled with a 7x7 PCF kernel that&rsquo;s implemented as an optimized, unrolled loop that makes use of GatherCmp instructions. This helps to make the actual workload somewhat representative of what you might have in actual game, instead of biasing things too much towards ALU work. My scene also has a directional light from the sun, which uses 4 2048x2048 cascaded shadow maps for visibility. Finally, an ambient term is applied by means of a set SH coefficients representing the radiance from the skydome.</p>
<h2 id="msaa-edge-detection-and-tile-classification">MSAA Edge Detection and Tile Classification<a href="#msaa-edge-detection-and-tile-classification" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Just like any other kind of deferred rendering, MSAA needs special care. In particular we need to determine which pixels contain multiple unique subsamples, so that we can shade each subsample individually during the deferred pass. The key issue here is scheduling: the &ldquo;edge&rdquo; pixels that require subsample shading will typically be rather sparse in screen space, which makes dynamic branching a poor fit. The &ldquo;old-school&rdquo; way of scheduling is to create a stencil mask from the edge pixels, and then render in two pixel shader passes: one pass for per-pixel shading, another for per-sample shading that runs the shader at per-sample frequency. This can work better than a branch, but the hardware still may not be able to schedule it particularly well due to the sparseness of the edge pixels. It will also still need to make sure that the shader runs with 2x2 quads, which can result in a lot of needless helper executions.</p>
<p>The &ldquo;newer&rdquo; way to schedule edge pixels (and by &ldquo;newer&rdquo;, I mean 6 years old) is to use a compute shader that re-schedules threads within a thread group. Basically you detect edge pixels, append their location to a list in thread group shared memory, and then have the entire group iterate over that list once it finishes shading the first subsample. This effectively compacts the sparse list of edge pixels within a tile, allowing for coherent looping and branching. The downside is that you need to use shared memory, which can decrease your maximum occupancy if you use too much of it.</p>
<p>In my sample, I use the compute shader approach but with a new twist. Instead of performing the edge detection in the deferred pass, I run an earlier pass that checks for edges and builds a mask. This pass uses append buffers to build a list of 8x8 tiles that contain edge pixels, as well as a separate list containing tiles that have no edges at all. The append counts are used as indirect arguments for ExecuteIndirect, so that the edge and non-edge tiles can processed with two separate dispatches using two different shader permutations. This helps minimize overhead from shared memory usage, since the non-edge version of the compute shader doesn&rsquo;t touch shared memory at all.</p>
<p>As for the actual edge detection, my sample supports two different approaches. The first approach only checks the material ID, and flags pixels that contain multiple material ID values. This is a very conservative approach, since it will only flag pixels where meshes with different materials overlap. The second approach is more aggressive, and additionally flags pixels with varying depth gradients. A varying depth gradient means that we have multiple triangles that are not coplanar, which means that we avoid tagging edges for the case of a tessellated flat plane. Here&rsquo;s what the edge detection looks like using only the material ID:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/msaa_mask_materialid.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/msaa_mask_materialid.png" alt="MSAA_Mask_MaterialID"></a></p>
<p>&hellip;and with the the more aggressive depth gradient check:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/msaa_mask_zgradients1.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/msaa_mask_zgradients1.png" alt="MSAA_Mask_ZGradients"></a></p>
<h2 id="decals">Decals<a href="#decals" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>One of the big advantages of traditional deferred shading is that you can modify your G-Buffer before computing your lighting. Lots of games take advantage of this by rendering <a href="http://www.slideshare.net/blindrenderer/screen-space-decals-in-warhammer-40000-space-marine-14699854">deferred decals</a>[14] into the scene for things like graffiti, blood splatter, debris, and posters. It&rsquo;s much nicer than traditional forward-rendered decals, since you only need to light once per pixel even when accumulating multiple decals. The typical approach is to apply these decals in a deferred pass prior to lighting, where bounding volumes are rasterized representing the area of influence for each decal. In the pixel shader, the depth buffer is used to compute a surface position, which is then projected into 2D in order to compute a UV value. The projected UV can then be used to sample textures containing the decal&rsquo;s surface properties, which are then written out to be blended into the G-Buffer. The end result is cheap decals that can work on complex scene geometry.</p>
<p>To use a typical deferred decal system you need two things: a depth buffer, and a G-Buffer. The depth buffer is needed for the projection part, and the G-Buffer is needed so that you can blend in your properties before shading. For forward rendering you can get a depth buffer through a depth prepass, but you&rsquo;re out of luck for the G-Buffer part. We&rsquo;re in a similar position with deferred texturing: we have depth, but our G-Buffer lacks the parameters that we&rsquo;d typically want to modify from a decal. For The Order I worked around this by making a very specialized decal system. We would essentially accumulate values into a render target, with each channel of the texture corresponding to specific hard-coded decal type: bullet damage/cratering, scorching, and blood. The forward shaders would then read in those values, and would use them to modify material parameters before performing the lighting phase of the shader. It worked, but it obviously was super-specific to our game and wasn&rsquo;t at all generic. Although we did get two nice things from this approach: materials could customize how they reacted to decals (materials could actually allocate a fully-composited layer for the damaged areas inside of bullet decals), and decals would properly accumulate on top of one another.</p>
<p>The good news is that deferred projectors is definitely not the only way to do decals. You can actually remove the need for a both a depth buffer <em>and</em> a G-Buffer by switching to the same clustered approach that you can use for lights, which is an idea I&rsquo;ve been kicking around for a year or two now. You just need to build a per-cluster list of decals, iterate over the list in your shading pass, and apply the decal according to its projection. The catch is that our shading pass now needs access to the textures for every possible decal in the scene, and it needs to be able to access the appropriate texture based on a decal index. In D3D11 this would have meant using texture arrays or atlases, but with D3D12 we can potentially avoid these headaches thanks to power of bindless.</p>
<p>So does a clustered approach to decals actually work? Why, yes it does! I implemented them in my app, and got them to work with both the clustered forward and deferred texturing rendering paths. I even made a picker so that you can splat decals wherever you want in the scene, which is lots of fun! The decals themselves are just a set of sci-fi color and normal maps, and were <a href="http://nobiax.deviantart.com/art/Free-Decals-02-Sci-Fi-329262452">generously provided for free by Nobiax</a> from DeviantArt[15]. They end up looking like this:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/decals.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/decals.png" alt="Decals"></a></p>
<p>In my demo the decal color and normal are just blended with the surface parameters based on the alpha channel from the color texture. However one advantage of applying decals in this way is that you&rsquo;re not restricted to framebuffer blending operations. So for instance, you can accumulate surface normals by <a href="http://blog.selfshadow.com/publications/blending-in-detail/">reorienting the decal normals</a>[19] to make them relative to the normals of the underlying surface.</p>
<p>As for their performance, I unfortunately don&rsquo;t have another decal implementation to compare against. However if I set up test case where most of the screen is covered in around 11 decals, the cost of the deferred pass (no MSAA) goes from 1.50ms to 2.00ms on my GTX 970. If I branch over the decals entirely (including reading from the cluster bitfield buffer), then the cost drops to 1.33ms. For the forward path it costs about 1.55ms with no decals, 2.20ms with decals, and 1.38 branching over the entire decal step.</p>
<h2 id="performance">Performance<a href="#performance" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>To measure performance, I captured GPU timing information via timestamp queries. All measurements were taken from the default camera position, at 1920x1080 resolution. The test scene is the CryTek Sponza (we really need a new test scene!) with 20 hand-placed spotlights, each casting a 1024x1024 shadow map. There&rsquo;s also a directional light for the sun that uses 4 2048x2048 shadow cascades. The scene uses normal, albedo, roughness, and metallic maps courtesy of <a href="http://www.alexandre-pestana.com/pbr-textures-sponza/">Alexandre Pestana</a>[16]. Here&rsquo;s what the frame breakdown looks like for the deferred texturing path, with no MSAA:</p>
<pre><code>Render Total: 7.40ms (7.47ms max)
Cluster Update: 0.08ms (0.08ms max)
Sun Shadow Map Rendering: 1.30ms (1.34ms max)
Spot Light Shadow Map Rendering: 1.04ms (1.04ms max)
G-Buffer Rendering: 0.67ms (0.67ms max)
Deferred Rendering: 3.54ms (3.58ms max)
Post Processing: 0.59ms (0.60ms max)
</code></pre><p>&hellip;and here&rsquo;s what it looks like with 4x MSAA:</p>
<pre><code>Render Total: 9.86ms (9.97ms max)
Cluster Update: 0.08ms (0.08ms max)
Sun Shadow Map Rendering: 1.30ms (1.34ms max)
Spot Light Shadow Map Rendering: 1.04ms (1.05ms max)
G-Buffer Rendering: 1.48ms (1.49ms max)
Deferred Rendering: 4.64ms (4.67ms max)
Post Processing: 0.56ms (0.57ms max)
MSAA Mask: 0.16ms (0.16ms max)
MSAA Resolve: 0.21ms (0.21ms max)
</code></pre><p>The first timing number is an average over the past 64 frames, while the second number is the maximum time from the past 64 frames.</p>
<p>The following chart shows how some of the various configurations scale with increasing MSAA levels:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx970-timings-7x7-pcf1.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx970-timings-7x7-pcf1.png" alt="GTX970 Timings - 7x7 PCF"></a></p>
<p>So there&rsquo;s a few observations that we can make from this data. First of all, the deferred path generally does very well compared to the forward path. The forward path without a depth prepass is basically useless, which means we&rsquo;re clearly suffering from overdraw problems. I do actually sort by depth when rendering the main forward pass, but  my test scene doesn&rsquo;t have sufficient granularity to achieve good front-to-back ordering. Enabling the depth prepass improves things considerably, but not enough to match the deferred performance. Once we enable MSAA things go a little differently, as the forward paths scale up better compared to the deferred rendering path. At 4x forward and deferred are nearly tied, but that is only when the deferred path uses the conservative material ID check for detecting edge pixels. The conservative path skips many edges in the test scene, and so the AA quality is inferior to the forward path. Using the aggressive depth gradient edge test brings the quality more in line with the forward path, but it&rsquo;s also quite a bit more expensive. However I would also expect the forward path to scale more poorly with scene complexity, since pixel shader efficiency will only decrease as the triangle count increases. One other interesting observation we can make is that writing out the UV gradients doesn&rsquo;t seem to be an issue for our test scene when running on my 970. With no MSAA it&rsquo;s actually slightly faster (7.47ms vs 7.50ms) to just write out the gradients instead of computing them, but that changes by the time we get to 4x MSAA (9.97ms vs. 9.83ms).</p>
<p>I should point out that all of these timings were captured while using a heavy-duty, &ldquo;thrash your cache&rdquo; 7x7 PCF kernel that&rsquo;s implemented as an unrolled loop using GatherCmp. It undoubtedly causes a large increase in memory traffic, and it probably causes an increase in register pressure as well. I would imagine that this is especially bad for the forward path, since everything is done in one pixel shader. As an alternative, I also have an option to revert back to a simple 2x2 PCF kernel that only uses a single GatherCmp (you can toggle it yourself by changing the &ldquo;UseGatherPCF_&rdquo; flag at the top of Shading.hlsl). This path is probably a better representation for games that use filterable shadow maps, and possibly games that use aggressive PCF sampling optimizations. Here&rsquo;s what the data looks like:</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx970-timings-2x2-pcf1.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx970-timings-2x2-pcf1.png" alt="GTX970 Timings - 2x2 PCF"></a></p>
<p>Some of these results are quite different compared to the 7x7 case. The forward paths do much better than they did previously, especially at 4xMSAA. The deferred paths scale the same as they did before, with the aggressive edge detection again causing longer frame times.</p>
<p>At home I only have access to a GTX 970, and so that&rsquo;s what I used for almost all of my testing, profiling, and optimization. However I was able to verify that the demo works on an an AMD R9 280, as well as a GTX 980. I&rsquo;ve posted a summary of all of the performance data in table form below (all timings in milliseconds):</p>
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx-970-2x2-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx-970-2x2-pcf.png" alt="GTX 970 - 2x2 PCF"></a></p>
<!-- raw HTML omitted -->
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx-970-7x7-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx-970-7x7-pcf.png" alt="GTX 970 - 7x7 PCF"></a></p>
<!-- raw HTML omitted -->
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx-980-2x2-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx-980-2x2-pcf.png" alt="GTX 980 - 2x2 PCF"></a></p>
<!-- raw HTML omitted -->
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/gtx-980-7x7-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/gtx-980-7x7-pcf.png" alt="GTX 980 - 7x7 PCF"></a></p>
<!-- raw HTML omitted -->
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/r9-380-2x2-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/r9-380-2x2-pcf.png" alt="R9 380 - 2x2 PCF"></a></p>
<!-- raw HTML omitted -->
<p><a href="https://mynameismjp.files.wordpress.com/2016/03/r9-380-7x7-pcf.png"><img src="https://mynameismjp.files.wordpress.com/2016/03/r9-380-7x7-pcf.png" alt="R9 380 - 7x7 PCF"></a></p>
<!-- raw HTML omitted -->
<p>If you&rsquo;re interested in seeing the raw performance data that includes the per-frame breakdowns, I&rsquo;ve uploaded them here: 
<a href="https://mynameismjp.files.wordpress.com/2016/03/deferred-texturing-timings.zip">https://mynameismjp.files.wordpress.com/2016/03/deferred-texturing-timings.zip</a>. You can also access the timing data in the app by clicking on the &ldquo;Timings&rdquo; button in the top-left corner of the screen.</p>
<h2 id="conclusions-and-future-work">Conclusions and Future Work<a href="#conclusions-and-future-work" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>So what kind of conclusions can we draw from this experiment? Personally I&rsquo;m wary of extrapolating too much from such an artificial testing scenario with only one basis for comparison, but I think it&rsquo;s safe to say that the bindless deferred texturing approach doesn&rsquo;t have any sort of inherent performance issue that would render it useless for games. Or at least, it doesn&rsquo;t on the limited hardware that I&rsquo;ve used for testing. I was initially worried that the combination of SampleGrad and divergent descriptor indices would lead to to suboptimal performance, but in the end it didn&rsquo;t seem to be an issue for my particular setup. Although to be completely fair, the texture sampling ended up being a relatively small part of the shading process. It&rsquo;s certainly possible that the situation could change if the number of textures were to increase, or if the indexing became more divergent due to increased material density in screen-space.  But at the same time those situations could also lead to reduced performance during a forward pass or during a traditional G-Buffer pass, so it might end up being a wash anyway.</p>
<p>At least in my demo, the biggest performance issue for the deferred path seems to be MSAA. This shouldn&rsquo;t really be a surprise, considering how hard it is to implement affordable MSAA with any deferred renderer. My hope would be that a deferred texturing approach does a bit better than a traditional deferred renderer with a very large G-Buffer, but unfortunately I don&rsquo;t have data to prove that out. Ultimately it probably doesn&rsquo;t even matter, since hardly anyone even bothers with MSAA these days. :(</p>
<p>What about limitations? Multiple UV sets are at best a headache, and at worst a non-option. I think you&rsquo;d have to really like your artists to store another UV set in your G-Buffer, and also eat the cost of storing or computing another set of UV gradients. Not having a full G-Buffer might be an issue for certain screen-space techniques, like SSAO or screen-space reflections. I&rsquo;ve shown that it&rsquo;s possible to have decals even without a full G-Buffer, but it&rsquo;s more complex and possibly more expensive than traditional deferred decals. But on the upside, it&rsquo;s really nice to have a cheap geometry pass that doesn&rsquo;t need to sample any textures! It&rsquo;s also very friendly to GPU-driven batching techniques, which was demonstrated in the RedLynx presentation from SIGGRAPH.</p>
<p>There is one final reason why you might not want to do this (or at least not right now): it was a real pain in the ass to get this demo working in DX12. Driver bugs, shader compilation bugs, long compile times, validation bugs, driver crashes, blue screens of death: if it was annoying, I ran into it. Dynamic indexing support seems to be rather immature in both the shader compiler and the drivers, so tread carefully. The final code has a few work-arounds implemented, but I&rsquo;ve noted them with a comment.</p>
<p><em>Update 8/4/2019: The situation has improved substantially since I wrote this article. Our engine at RAD now makes full use of bindless resources throughout its various rendering passes. Drivers have become much more robust, and the open source shader compiler (DXC) is much faster and more robust compared with FXC (which allowed me to remove some of my workarounds). I&rsquo;ve also used wave-level intrinsics from SM6.0 to implement scalarization techniques for loading the light/decal data, which forces wave coherency and can substantially reduce VGPR usage on AMD hardware. There is also now a GPU-based validation layer that can validate resources accessed through descriptor indexing, and PIX can now do a similar analysis to show which resources were actually used within a draw or dispatch.</em></p>
<p>If I were to spend more time on this, I think it would be interesting to explore some of the more extreme variants of deferred texturing. In particular there&rsquo;s Intel&rsquo;s paper on <a href="http://jcgt.org/published/0002/02/04/">Visibility Buffers</a>[17], where the authors completely forego storing any surface data except for triangle ID and instance ID. All surface data is instead reconstructed by transforming vertices during the deferred pass, and performing a ray-triangle intersection to compute barycentrics for interpolation. There&rsquo;s also Tomasz Stachowiak&rsquo;s presentation about <a href="https://onedrive.live.com/view.aspx?resid=EBE7DEDA70D06DA0!115&amp;app=PowerPoint&amp;authkey=!AP-pDh4IMUug6vs">deferred material rendering</a>[18], where barycentric coordinates are stored in the G-Buffer instead of being reconstructed (which he does by tricking the driver into accepting his hand-written GCN assembly!!!). He has some neat ideas about using tile classification to execute different shader paths based on the material, which is something that could be integrated with the MSAA tile classification that&rsquo;s performed in my demo. Finally in the RedLynx presentation they use a neat trick where they render with MSAA at half resolution, and then reconstruct full-resolution surface samples during the deferred pass. It makes the deferred shader more complicated, but reduces the pixel shader cost of rasterizing the G-Buffer. These are all things I would love to implement in my demo if I had infinite time, but at some point I actually need to sleep. :)</p>
<h2 id="thats-all-folks">That&rsquo;s All, Folks!<a href="#thats-all-folks" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>If you&rsquo;ve made it this far, thank you for hanging in there! This one might be my longest so far! I considering making it a series of articles, but I didn&rsquo;t want it to turn into one of those blog series where the author just never finishes it.</p>
<p>If you want to look at the code or run the sample, everything is available on GitHub:</p>
<p><a href="https://github.com/TheRealMJP/DeferredTexturing">https://github.com/TheRealMJP/DeferredTexturing</a></p>
<p><a href="https://github.com/TheRealMJP/DeferredTexturing/releases">https://github.com/TheRealMJP/DeferredTexturing/releases</a> (Precompiled Binaries)</p>
<p>If you find any bugs or have any suggestions, please let me know via comments, email, GitHub issue, or twitter!</p>
<h2 id="references">References<a href="#references" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>[1] <a href="https://software.intel.com/en-us/articles/introduction-to-resource-binding-in-microsoft-directx-12">Introduction To Resource Binding In D3D12 (Intel)</a><!-- raw HTML omitted -->
[2] <a href="http://developer.download.nvidia.com/opengl/tutorials/bindless_graphics.pdf">OpenGL Bindless Extensions (Nvidia)</a><!-- raw HTML omitted -->
[3] <a href="http://developer.download.nvidia.com/opengl/specs/GL_NV_bindless_texture.txt">GL_NV_bindless_texture (OpenGL Extension Registry)</a><!-- raw HTML omitted -->
[4] <a href="http://www.reedbeta.com/blog/2014/03/25/deferred-texturing/">Deferred Texturing (Nathan Reed)</a><!-- raw HTML omitted -->
[5] <a href="http://advances.realtimerendering.com/s2015/aaltonenhaar_siggraph2015_combined_final_footer_220dpi.pdf">GPU-Driven Rendering Pipelines (Haar and Aaltonen, SIGGRAPH 2015)</a><!-- raw HTML omitted -->
[6] <a href="https://forum.beyond3d.com/threads/modern-textureless-deferred-rendering-techniques.57611/">Modern Textureless Deferred Rendering Techniques (Beyond3D)</a><!-- raw HTML omitted -->
[7] <a href="http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html">The Bitsquid Low-Level Animation System</a><!-- raw HTML omitted -->
[8] <a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf">Practical Clustered Shading (Emil Persson)</a><!-- raw HTML omitted -->
[9] <a href="https://software.intel.com/en-us/articles/deferred-rendering-for-current-and-future-rendering-pipelines">Deferred Rendering for Current and Future Rendering Pipelines (Intel, Andrew Lauritzen)</a><!-- raw HTML omitted -->
[10] <a href="http://www.slideshare.net/takahiroharada/forward-34779335">Forward+: Bringing Deferred Lighting To The Next Level (AMD, Takahiro Harada)</a><!-- raw HTML omitted -->
[11] <a href="https://software.intel.com/en-us/articles/forward-clustered-shading">Forward Clustered Shading (Intel)</a><!-- raw HTML omitted -->
[12] <a href="http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm">Correct Frustum Culling (Íñigo Quílez)</a><!-- raw HTML omitted -->
[13] <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903791(v=vs.85).aspx">Conservative Rasterization (MSDN)</a><!-- raw HTML omitted -->
[14] <a href="http://www.slideshare.net/blindrenderer/screen-space-decals-in-warhammer-40000-space-marine-14699854">Screen Space Decals in Warhammer 40K: Space Marine (Pope Kim)</a><!-- raw HTML omitted -->
[15] <a href="http://nobiax.deviantart.com/art/Free-Decals-02-Sci-Fi-329262452">Free Sci-Fi Decals 2 (Nobiax, DeviantArt)</a><!-- raw HTML omitted -->
[16] <a href="http://www.alexandre-pestana.com/pbr-textures-sponza/">Base color, Roughness and Metallic textures for Sponza (Alexandre Pestana)</a><!-- raw HTML omitted -->
[17] <a href="http://jcgt.org/published/0002/02/04/">The Visibility Buffer: A Cache-Friendly Approach to Deferred Shading (Burns and Hunt, JCGT)</a><!-- raw HTML omitted -->
[18] <a href="https://onedrive.live.com/view.aspx?resid=EBE7DEDA70D06DA0!115&amp;app=PowerPoint&amp;authkey=!AP-pDh4IMUug6vs">A Deferred Material Rendering System (Tomasz Stachowiak)</a><!-- raw HTML omitted -->
[19] <a href="http://blog.selfshadow.com/publications/blending-in-detail/">Blending In Detail (Barré-Brisebois and Hill)</a><!-- raw HTML omitted --></p>
<hr>
<h3 id="comments">Comments:<a href="#comments" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="heading"><a href="#heading" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p><a href="http://gravatar.com/jeroenstout" title="jeroenstout@gmail.com">Jeroen D Stout</a> - <!-- raw HTML omitted -->Mar 5, 2016<!-- raw HTML omitted --></p>
<p>Thank you, as always, for sharing your ideas and tests so liberally, it has been very inspiring on many occasions. One thing this all made me think about is the recent interest in distance fields. The idea of using a scene approximation distance field for reflections is enticing to me, as I am mostly interested in depicting relatively small scenes as realistically as possible. Would you happen to have any ideas on rendering via a distance field, finding the intersection and using that (eventually) to fetch textures, materials, shaders, &amp;c? The deferred material rendering article made me think that is not as crazy as it may sound; and it might play nice (seeing all this) with reflections.</p>
<!-- raw HTML omitted -->
<p>Jeroen, a distance field intersection would only give you world position, so you&rsquo;d have to use a data structure that can evaluate a material entirely from that, not an easy thing to do efficiently! Plus you really need prefiltered results to solve the cone queries you are doing.</p>
<!-- raw HTML omitted -->
<p>Daniel, Hmm, to clarify, my thought was hypothetically you could store the &lsquo;nearest&rsquo; Mat-ID in the field (if it is a 3d texture) along with a U and a V (admittedly making it a much larger texture). That can get you a world position + UV + mat-ID and come closer to the data for &lsquo;deferred material rendering&rsquo;. It&rsquo;s perhaps not very practical.</p>
<!-- raw HTML omitted -->
<p>Any reason why you use buffers rather than 3D textures for cluster storage? Stylistic choice, or are there practical considerations? Really nice article and sample, thanks for sharing.</p>
<!-- raw HTML omitted -->
<p>Do you ever sleep? :) This is great work, thanks for sharing. I&rsquo;m particularly interested in the clustered decal approach, as forward pipelines have traditionally suffered from decal support. It seems like the magic bullet these days is tiled compute approaches! The textureless deferred stuff is interesting, but I&rsquo;m not sure I&rsquo;m sold. For one, it still suffers from high memory bandwidth, which means you still end up needing a Z-Prepass. More importantly though, high bandwidth deferred pipelines don&rsquo;t scale to higher resolutions. We&rsquo;ve hit a wall with our deferred pipeline in that we simply can&rsquo;t scale above 1080p and maintain any scene complexity. I&rsquo;d be interested to run this at a higher resolution and see how the performance compares.</p>
<!-- raw HTML omitted -->
<p>@ingramb: I mainly used a flat buffer so that I could easily vary the maximum number of lights and decals per cluster without having to worry about texture formats. But to be honest I didn&rsquo;t give it a whole lot of thought. @zbethel: the G-Buffer is definitely still fatter than I&rsquo;d like it to be. However I&rsquo;m not sure that you need a depth prepass. I used to have an option to turn on depth prepass for the deferred path, but I disabled it because it was never faster. That might not be the case on hardware with less bandwidth, but either way the G-Buffer pixel shader is *very* cheap. If you want to try it yourself you can re-enable it by uncommenting the code on line 1578 of BindlessDeferred.cpp. I think for lower-end desktop or mobile hardware that&rsquo;s more bandwidth-constrained, approaches like the Visibility Buffer start to look more appealing due to the ultra-slim G-Buffer. It&rsquo;s also nice for MSAA, for the same reason. If I run maximized on my 2560x1440 monitor on my GTX 970 I get 10.73ms for deferred, vs. 11.63ms for forward. At 4xMSAA this changes to 14.20ms for deferred (with computing UV gradients enabled), vs. 14.00ms for forward. Using the aggressive edge detection pushes the deferred path up to about 16.00ms.</p>
<!-- raw HTML omitted -->
<p>I&rsquo;d love to use this technique. But I ran into a troubling thought. In a normal deferred shading pipeline, any object that requires some unique shaders to do some fancy work to it&rsquo;s materials can just output that data to the correct GBuffer. However, how would you do that for deferred texturing? I don&rsquo;t think you can rebind your programs dynamically from the GPU.</p>
<!-- raw HTML omitted -->
<p>Thx a lot, it is this most inspriing article I have ever seen. Btw, would you like to try radiance hints (GI) some day?</p>
<!-- raw HTML omitted -->
<p>Hey Sean, glad you liked the post. I just tried compiling and running the latest code on my GTX 970, and I don&rsquo;t see either of those issues. Are you on the latest driver? I&rsquo;m currently running on driver 368.39, which is the latest available.</p>
<!-- raw HTML omitted -->
<p>This is great stuff, and a very educational post. One problem, though. I&rsquo;m testing out your demo, and there are some issues I&rsquo;m having, and wondering if they&rsquo;re known: 1. Lights flicker terribly in the Clustered Forward render mode, 2. In Deferred Texturing mode, there are many places where the UVs stretch across multiple polygons. These did not show up in your screenshots above, but I&rsquo;m running on a GTX 970 as well, so I wouldn&rsquo;t expect to see this. Ex: <a href="http://imgur.com/WoXtMjV">http://imgur.com/WoXtMjV</a></p>
<!-- raw HTML omitted -->
<p>Since the forward path is faster using 4xMSAA, is it still better to keep the deferred path ?</p>
<!-- raw HTML omitted -->
<p>Doh. Turns out this demo is the reason I upgraded to Windows 10, and in my rush, I forgot that my graphics driver would have to be manually updated. Works great now, thanks.</p>
<!-- raw HTML omitted -->
<p>[…] are few solutions to it. I will mention first a heavy / complicated, but best solution, suggested by Matt Pettineo – rasterizing the cone in tested space and then either simply checking against this […]</p>
<!-- raw HTML omitted -->

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://therealmjp.github.io/tags/directx-12">DirectX 12</a></span><span class="tag"><a href="https://therealmjp.github.io/tags/graphics">Graphics</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>7534 Words</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>2016-03-25 01:39 -0700</p>
			</footer>
		</article>
		<div class="post-nav thin">
			<a class="next-post" href="https://therealmjp.github.io/posts/new-blog-series-lightmap-baking-and-spherical-gaussians/">
				<span class="post-nav-label"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>&nbsp;Newer</span><br><span>New Blog Series: Lightmap Baking and Spherical Gaussians</span>
			</a>
			<a class="prev-post" href="https://therealmjp.github.io/posts/update-for-my-shadow-sample-update/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Update For My Shadow Sample Update</span>
			</a>
		</div>
		<div id="comments" class="thin"><script src="https://utteranc.es/client.js"
        repo="TheRealMJP/TheRealMJP.github.io"
        issue-term="title"
        label="comments"
        theme="photon-dark"
        crossorigin="anonymous"
        async>
</script></div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2020 <a href="https://therealmjp.github.io/">MJP</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://therealmjp.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>


	<script src="https://therealmjp.github.io/js/main.min.d1b247cbe4b98a4f2db4cae020d2b180d0b585a34ed4d751cb0072d5676fc52a.js" integrity="sha256-0bJHy+S5ik8ttMrgINKxgNC1haNO1NdRywBy1WdvxSo="></script>



</body>

</html>
